import{N as le,T as y,A as Y,O as ee,R as Re,a as Ae,b as Ne,c as w,d as Se,i as Xn,e as jn,f as dn,g as qn,P as fn,h as pt,B as Lt,t as mn,j as Tn,k as j,l as Ct,G as Oe,s as Jn}from"./@chevrotain-D6nI8fqk.js";import{f as R,d as P,u as xt,m as E,g as z,a as It,v as x,h as K,e as q,j as Ie,c as b,k as Pt,r as nt,b as ae,l as Ee,i as J,n as te,o as $t,q as g,t as D,w as O,x as W,y as st,z as be,A as X,B as Fe,C as M,D as Bt,E as C,F as ge,G as we,H as $,I as Qn,p as Zn,J as es,s as ts}from"./lodash-es-DC2U6FIr.js";class rt{walk(e,t=[]){R(e.definition,(s,r)=>{const i=P(e.definition,r+1);if(s instanceof le)this.walkProdRef(s,i,t);else if(s instanceof y)this.walkTerminal(s,i,t);else if(s instanceof Y)this.walkFlat(s,i,t);else if(s instanceof ee)this.walkOption(s,i,t);else if(s instanceof Re)this.walkAtLeastOne(s,i,t);else if(s instanceof Ae)this.walkAtLeastOneSep(s,i,t);else if(s instanceof Ne)this.walkManySep(s,i,t);else if(s instanceof w)this.walkMany(s,i,t);else if(s instanceof Se)this.walkOr(s,i,t);else throw Error("non exhaustive match")})}walkTerminal(e,t,s){}walkProdRef(e,t,s){}walkFlat(e,t,s){const r=t.concat(s);this.walk(e,r)}walkOption(e,t,s){const r=t.concat(s);this.walk(e,r)}walkAtLeastOne(e,t,s){const r=[new ee({definition:e.definition})].concat(t,s);this.walk(e,r)}walkAtLeastOneSep(e,t,s){const r=Wt(e,t,s);this.walk(e,r)}walkMany(e,t,s){const r=[new ee({definition:e.definition})].concat(t,s);this.walk(e,r)}walkManySep(e,t,s){const r=Wt(e,t,s);this.walk(e,r)}walkOr(e,t,s){const r=t.concat(s);R(e.definition,i=>{const o=new Y({definition:[i]});this.walk(o,r)})}}function Wt(n,e,t){return[new ee({definition:[new y({terminalType:n.separator})].concat(n.definition)})].concat(e,t)}function Ue(n){if(n instanceof le)return Ue(n.referencedRule);if(n instanceof y)return rs(n);if(Xn(n))return ns(n);if(jn(n))return ss(n);throw Error("non exhaustive match")}function ns(n){let e=[];const t=n.definition;let s=0,r=t.length>s,i,o=!0;for(;r&&o;)i=t[s],o=dn(i),e=e.concat(Ue(i)),s=s+1,r=t.length>s;return xt(e)}function ss(n){const e=E(n.definition,t=>Ue(t));return xt(z(e))}function rs(n){return[n.terminalType]}const En="_~IN~_";class is extends rt{constructor(e){super(),this.topProd=e,this.follows={}}startWalking(){return this.walk(this.topProd),this.follows}walkTerminal(e,t,s){}walkProdRef(e,t,s){const r=as(e.referencedRule,e.idx)+this.topProd.name,i=t.concat(s),o=new Y({definition:i}),a=Ue(o);this.follows[r]=a}}function os(n){const e={};return R(n,t=>{const s=new is(t).startWalking();It(e,s)}),e}function as(n,e){return n.name+e+En}let ze={};const cs=new qn;function it(n){const e=n.toString();if(ze.hasOwnProperty(e))return ze[e];{const t=cs.pattern(e);return ze[e]=t,t}}function ls(){ze={}}const pn="Complement Sets are not supported for first char optimization",qe=`Unable to use "first char" lexer optimizations:
`;function hs(n,e=!1){try{const t=it(n);return gt(t.value,{},t.flags.ignoreCase)}catch(t){if(t.message===pn)e&&fn(`${qe}	Unable to optimize: < ${n.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);else{let s="";e&&(s=`
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`),pt(`${qe}
	Failed parsing: < ${n.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues`+s)}}return[]}function gt(n,e,t){switch(n.type){case"Disjunction":for(let r=0;r<n.value.length;r++)gt(n.value[r],e,t);break;case"Alternative":const s=n.value;for(let r=0;r<s.length;r++){const i=s[r];switch(i.type){case"EndAnchor":case"GroupBackReference":case"Lookahead":case"NegativeLookahead":case"StartAnchor":case"WordBoundary":case"NonWordBoundary":continue}const o=i;switch(o.type){case"Character":We(o.value,e,t);break;case"Set":if(o.complement===!0)throw Error(pn);R(o.value,c=>{if(typeof c=="number")We(c,e,t);else{const l=c;if(t===!0)for(let h=l.from;h<=l.to;h++)We(h,e,t);else{for(let h=l.from;h<=l.to&&h<ye;h++)We(h,e,t);if(l.to>=ye){const h=l.from>=ye?l.from:ye,u=l.to,m=ce(h),I=ce(u);for(let A=m;A<=I;A++)e[A]=A}}}});break;case"Group":gt(o.value,e,t);break;default:throw Error("Non Exhaustive Match")}const a=o.quantifier!==void 0&&o.quantifier.atLeast===0;if(o.type==="Group"&&Rt(o)===!1||o.type!=="Group"&&a===!1)break}break;default:throw Error("non exhaustive match!")}return x(e)}function We(n,e,t){const s=ce(n);e[s]=s,t===!0&&us(n,e)}function us(n,e){const t=String.fromCharCode(n),s=t.toUpperCase();if(s!==t){const r=ce(s.charCodeAt(0));e[r]=r}else{const r=t.toLowerCase();if(r!==t){const i=ce(r.charCodeAt(0));e[i]=i}}}function Ht(n,e){return Ie(n.value,t=>{if(typeof t=="number")return b(e,t);{const s=t;return Ie(e,r=>s.from<=r&&r<=s.to)!==void 0}})}function Rt(n){const e=n.quantifier;return e&&e.atLeast===0?!0:n.value?K(n.value)?q(n.value,Rt):Rt(n.value):!1}class ds extends Lt{constructor(e){super(),this.targetCharCodes=e,this.found=!1}visitChildren(e){if(this.found!==!0){switch(e.type){case"Lookahead":this.visitLookahead(e);return;case"NegativeLookahead":this.visitNegativeLookahead(e);return}super.visitChildren(e)}}visitCharacter(e){b(this.targetCharCodes,e.value)&&(this.found=!0)}visitSet(e){e.complement?Ht(e,this.targetCharCodes)===void 0&&(this.found=!0):Ht(e,this.targetCharCodes)!==void 0&&(this.found=!0)}}function yt(n,e){if(e instanceof RegExp){const t=it(e),s=new ds(n);return s.visit(t),s.found}else return Ie(e,t=>b(n,t.charCodeAt(0)))!==void 0}const me="PATTERN",Pe="defaultMode",He="modes";let In=typeof new RegExp("(?:)").sticky=="boolean";function fs(n,e){e=Pt(e,{useSticky:In,debug:!1,safeMode:!1,positionTracking:"full",lineTerminatorCharacters:["\r",`
`],tracer:(f,d)=>d()});const t=e.tracer;t("initCharCodeToOptimizedIndexMap",()=>{bs()});let s;t("Reject Lexer.NA",()=>{s=nt(n,f=>f[me]===B.NA)});let r=!1,i;t("Transform Patterns",()=>{r=!1,i=E(s,f=>{const d=f[me];if(ae(d)){const p=d.source;return p.length===1&&p!=="^"&&p!=="$"&&p!=="."&&!d.ignoreCase?p:p.length===2&&p[0]==="\\"&&!b(["d","D","s","S","t","r","n","t","0","c","b","B","f","v","w","W"],p[1])?p[1]:e.useSticky?zt(d):Vt(d)}else{if(Ee(d))return r=!0,{exec:d};if(typeof d=="object")return r=!0,d;if(typeof d=="string"){if(d.length===1)return d;{const p=d.replace(/[\\^$.*+?()[\]{}|]/g,"\\$&"),k=new RegExp(p);return e.useSticky?zt(k):Vt(k)}}else throw Error("non exhaustive match")}})});let o,a,c,l,h;t("misc mapping",()=>{o=E(s,f=>f.tokenTypeIdx),a=E(s,f=>{const d=f.GROUP;if(d!==B.SKIPPED){if(J(d))return d;if(te(d))return!1;throw Error("non exhaustive match")}}),c=E(s,f=>{const d=f.LONGER_ALT;if(d)return K(d)?E(d,k=>$t(s,k)):[$t(s,d)]}),l=E(s,f=>f.PUSH_MODE),h=E(s,f=>g(f,"POP_MODE"))});let u;t("Line Terminator Handling",()=>{const f=An(e.lineTerminatorCharacters);u=E(s,d=>!1),e.positionTracking!=="onlyOffset"&&(u=E(s,d=>g(d,"LINE_BREAKS")?!!d.LINE_BREAKS:Rn(d,f)===!1&&yt(f,d.PATTERN)))});let m,I,A,N;t("Misc Mapping #2",()=>{m=E(s,gn),I=E(i,vs),A=D(s,(f,d)=>{const p=d.GROUP;return J(p)&&p!==B.SKIPPED&&(f[p]=[]),f},{}),N=E(i,(f,d)=>({pattern:i[d],longerAlt:c[d],canLineTerminator:u[d],isCustom:m[d],short:I[d],group:a[d],push:l[d],pop:h[d],tokenTypeIdx:o[d],tokenType:s[d]}))});let S=!0,T=[];return e.safeMode||t("First Char Optimization",()=>{T=D(s,(f,d,p)=>{if(typeof d.PATTERN=="string"){const k=d.PATTERN.charCodeAt(0),H=ce(k);ft(f,H,N[p])}else if(K(d.START_CHARS_HINT)){let k;R(d.START_CHARS_HINT,H=>{const se=typeof H=="string"?H.charCodeAt(0):H,ue=ce(se);k!==ue&&(k=ue,ft(f,ue,N[p]))})}else if(ae(d.PATTERN))if(d.PATTERN.unicode)S=!1,e.ensureOptimizations&&pt(`${qe}	Unable to analyze < ${d.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);else{const k=hs(d.PATTERN,e.ensureOptimizations);O(k)&&(S=!1),R(k,H=>{ft(f,H,N[p])})}else e.ensureOptimizations&&pt(`${qe}	TokenType: <${d.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),S=!1;return f},[])}),{emptyGroups:A,patternIdxToConfig:N,charCodeToPatternIdxToConfig:T,hasCustom:r,canBeOptimized:S}}function ms(n,e){let t=[];const s=Es(n);t=t.concat(s.errors);const r=ps(s.valid),i=r.valid;return t=t.concat(r.errors),t=t.concat(Ts(i)),t=t.concat(_s(i)),t=t.concat(ks(i,e)),t=t.concat(Ls(i)),t}function Ts(n){let e=[];const t=W(n,s=>ae(s[me]));return e=e.concat(gs(t)),e=e.concat(Ns(t)),e=e.concat(Ss(t)),e=e.concat(Os(t)),e=e.concat(Rs(t)),e}function Es(n){const e=W(n,r=>!g(r,me)),t=E(e,r=>({message:"Token Type: ->"+r.name+"<- missing static 'PATTERN' property",type:L.MISSING_PATTERN,tokenTypes:[r]})),s=st(n,e);return{errors:t,valid:s}}function ps(n){const e=W(n,r=>{const i=r[me];return!ae(i)&&!Ee(i)&&!g(i,"exec")&&!J(i)}),t=E(e,r=>({message:"Token Type: ->"+r.name+"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",type:L.INVALID_PATTERN,tokenTypes:[r]})),s=st(n,e);return{errors:t,valid:s}}const Is=/[^\\][$]/;function gs(n){class e extends Lt{constructor(){super(...arguments),this.found=!1}visitEndAnchor(i){this.found=!0}}const t=W(n,r=>{const i=r.PATTERN;try{const o=it(i),a=new e;return a.visit(o),a.found}catch{return Is.test(i.source)}});return E(t,r=>({message:`Unexpected RegExp Anchor Error:
	Token Type: ->`+r.name+`<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,type:L.EOI_ANCHOR_FOUND,tokenTypes:[r]}))}function Rs(n){const e=W(n,s=>s.PATTERN.test(""));return E(e,s=>({message:"Token Type: ->"+s.name+"<- static 'PATTERN' must not match an empty string",type:L.EMPTY_MATCH_PATTERN,tokenTypes:[s]}))}const As=/[^\\[][\^]|^\^/;function Ns(n){class e extends Lt{constructor(){super(...arguments),this.found=!1}visitStartAnchor(i){this.found=!0}}const t=W(n,r=>{const i=r.PATTERN;try{const o=it(i),a=new e;return a.visit(o),a.found}catch{return As.test(i.source)}});return E(t,r=>({message:`Unexpected RegExp Anchor Error:
	Token Type: ->`+r.name+`<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,type:L.SOI_ANCHOR_FOUND,tokenTypes:[r]}))}function Ss(n){const e=W(n,s=>{const r=s[me];return r instanceof RegExp&&(r.multiline||r.global)});return E(e,s=>({message:"Token Type: ->"+s.name+"<- static 'PATTERN' may NOT contain global('g') or multiline('m')",type:L.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[s]}))}function Os(n){const e=[];let t=E(n,i=>D(n,(o,a)=>(i.PATTERN.source===a.PATTERN.source&&!b(e,a)&&a.PATTERN!==B.NA&&(e.push(a),o.push(a)),o),[]));t=be(t);const s=W(t,i=>i.length>1);return E(s,i=>{const o=E(i,c=>c.name);return{message:`The same RegExp pattern ->${X(i).PATTERN}<-has been used in all of the following Token Types: ${o.join(", ")} <-`,type:L.DUPLICATE_PATTERNS_FOUND,tokenTypes:i}})}function _s(n){const e=W(n,s=>{if(!g(s,"GROUP"))return!1;const r=s.GROUP;return r!==B.SKIPPED&&r!==B.NA&&!J(r)});return E(e,s=>({message:"Token Type: ->"+s.name+"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",type:L.INVALID_GROUP_TYPE_FOUND,tokenTypes:[s]}))}function ks(n,e){const t=W(n,r=>r.PUSH_MODE!==void 0&&!b(e,r.PUSH_MODE));return E(t,r=>({message:`Token Type: ->${r.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${r.PUSH_MODE}<-which does not exist`,type:L.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[r]}))}function Ls(n){const e=[],t=D(n,(s,r,i)=>{const o=r.PATTERN;return o===B.NA||(J(o)?s.push({str:o,idx:i,tokenType:r}):ae(o)&&xs(o)&&s.push({str:o.source,idx:i,tokenType:r})),s},[]);return R(n,(s,r)=>{R(t,({str:i,idx:o,tokenType:a})=>{if(r<o&&Cs(i,s.PATTERN)){const c=`Token: ->${a.name}<- can never be matched.
Because it appears AFTER the Token Type ->${s.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;e.push({message:c,type:L.UNREACHABLE_PATTERN,tokenTypes:[s,a]})}})}),e}function Cs(n,e){if(ae(e)){const t=e.exec(n);return t!==null&&t.index===0}else{if(Ee(e))return e(n,0,[],{});if(g(e,"exec"))return e.exec(n,0,[],{});if(typeof e=="string")return e===n;throw Error("non exhaustive match")}}function xs(n){return Ie([".","\\","[","]","|","^","$","(",")","?","*","+","{"],t=>n.source.indexOf(t)!==-1)===void 0}function Vt(n){const e=n.ignoreCase?"i":"";return new RegExp(`^(?:${n.source})`,e)}function zt(n){const e=n.ignoreCase?"iy":"y";return new RegExp(`${n.source}`,e)}function Ps(n,e,t){const s=[];return g(n,Pe)||s.push({message:"A MultiMode Lexer cannot be initialized without a <"+Pe+`> property in its definition
`,type:L.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),g(n,He)||s.push({message:"A MultiMode Lexer cannot be initialized without a <"+He+`> property in its definition
`,type:L.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),g(n,He)&&g(n,Pe)&&!g(n.modes,n.defaultMode)&&s.push({message:`A MultiMode Lexer cannot be initialized with a ${Pe}: <${n.defaultMode}>which does not exist
`,type:L.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),g(n,He)&&R(n.modes,(r,i)=>{R(r,(o,a)=>{if(te(o))s.push({message:`A Lexer cannot be initialized using an undefined Token Type. Mode:<${i}> at index: <${a}>
`,type:L.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});else if(g(o,"LONGER_ALT")){const c=K(o.LONGER_ALT)?o.LONGER_ALT:[o.LONGER_ALT];R(c,l=>{!te(l)&&!b(r,l)&&s.push({message:`A MultiMode Lexer cannot be initialized with a longer_alt <${l.name}> on token <${o.name}> outside of mode <${i}>
`,type:L.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE})})}})}),s}function ys(n,e,t){const s=[];let r=!1;const i=be(z(x(n.modes))),o=nt(i,c=>c[me]===B.NA),a=An(t);return e&&R(o,c=>{const l=Rn(c,a);if(l!==!1){const u={message:ws(c,l),type:l.issue,tokenType:c};s.push(u)}else g(c,"LINE_BREAKS")?c.LINE_BREAKS===!0&&(r=!0):yt(a,c.PATTERN)&&(r=!0)}),e&&!r&&s.push({message:`Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`,type:L.NO_LINE_BREAKS_FLAGS}),s}function Ms(n){const e={},t=Fe(n);return R(t,s=>{const r=n[s];if(K(r))e[s]=[];else throw Error("non exhaustive match")}),e}function gn(n){const e=n.PATTERN;if(ae(e))return!1;if(Ee(e))return!0;if(g(e,"exec"))return!0;if(J(e))return!1;throw Error("non exhaustive match")}function vs(n){return J(n)&&n.length===1?n.charCodeAt(0):!1}const Fs={test:function(n){const e=n.length;for(let t=this.lastIndex;t<e;t++){const s=n.charCodeAt(t);if(s===10)return this.lastIndex=t+1,!0;if(s===13)return n.charCodeAt(t+1)===10?this.lastIndex=t+2:this.lastIndex=t+1,!0}return!1},lastIndex:0};function Rn(n,e){if(g(n,"LINE_BREAKS"))return!1;if(ae(n.PATTERN)){try{yt(e,n.PATTERN)}catch(t){return{issue:L.IDENTIFY_TERMINATOR,errMsg:t.message}}return!1}else{if(J(n.PATTERN))return!1;if(gn(n))return{issue:L.CUSTOM_LINE_BREAK};throw Error("non exhaustive match")}}function ws(n,e){if(e.issue===L.IDENTIFY_TERMINATOR)return`Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${n.name}> Token Type
	 Root cause: ${e.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;if(e.issue===L.CUSTOM_LINE_BREAK)return`Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${n.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;throw Error("non exhaustive match")}function An(n){return E(n,t=>J(t)?t.charCodeAt(0):t)}function ft(n,e,t){n[e]===void 0?n[e]=[t]:n[e].push(t)}const ye=256;let Ye=[];function ce(n){return n<ye?n:Ye[n]}function bs(){if(O(Ye)){Ye=new Array(65536);for(let n=0;n<65536;n++)Ye[n]=n>255?255+~~(n/255):n}}function De(n,e){const t=n.tokenTypeIdx;return t===e.tokenTypeIdx?!0:e.isParent===!0&&e.categoryMatchesMap[t]===!0}function Je(n,e){return n.tokenTypeIdx===e.tokenTypeIdx}let Yt=1;const Nn={};function Ge(n){const e=Us(n);Ds(e),Ks(e),Gs(e),R(e,t=>{t.isParent=t.categoryMatches.length>0})}function Us(n){let e=M(n),t=n,s=!0;for(;s;){t=be(z(E(t,i=>i.CATEGORIES)));const r=st(t,e);e=e.concat(r),O(r)?s=!1:t=r}return e}function Ds(n){R(n,e=>{On(e)||(Nn[Yt]=e,e.tokenTypeIdx=Yt++),Xt(e)&&!K(e.CATEGORIES)&&(e.CATEGORIES=[e.CATEGORIES]),Xt(e)||(e.CATEGORIES=[]),$s(e)||(e.categoryMatches=[]),Bs(e)||(e.categoryMatchesMap={})})}function Gs(n){R(n,e=>{e.categoryMatches=[],R(e.categoryMatchesMap,(t,s)=>{e.categoryMatches.push(Nn[s].tokenTypeIdx)})})}function Ks(n){R(n,e=>{Sn([],e)})}function Sn(n,e){R(n,t=>{e.categoryMatchesMap[t.tokenTypeIdx]=!0}),R(e.CATEGORIES,t=>{const s=n.concat(e);b(s,t)||Sn(s,t)})}function On(n){return g(n,"tokenTypeIdx")}function Xt(n){return g(n,"CATEGORIES")}function $s(n){return g(n,"categoryMatches")}function Bs(n){return g(n,"categoryMatchesMap")}function Ws(n){return g(n,"tokenTypeIdx")}const Hs={buildUnableToPopLexerModeMessage(n){return`Unable to pop Lexer Mode after encountering Token ->${n.image}<- The Mode Stack is empty`},buildUnexpectedCharactersMessage(n,e,t,s,r){return`unexpected character: ->${n.charAt(e)}<- at offset: ${e}, skipped ${t} characters.`}};var L;(function(n){n[n.MISSING_PATTERN=0]="MISSING_PATTERN",n[n.INVALID_PATTERN=1]="INVALID_PATTERN",n[n.EOI_ANCHOR_FOUND=2]="EOI_ANCHOR_FOUND",n[n.UNSUPPORTED_FLAGS_FOUND=3]="UNSUPPORTED_FLAGS_FOUND",n[n.DUPLICATE_PATTERNS_FOUND=4]="DUPLICATE_PATTERNS_FOUND",n[n.INVALID_GROUP_TYPE_FOUND=5]="INVALID_GROUP_TYPE_FOUND",n[n.PUSH_MODE_DOES_NOT_EXIST=6]="PUSH_MODE_DOES_NOT_EXIST",n[n.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]="MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE",n[n.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]="MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY",n[n.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]="MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST",n[n.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]="LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED",n[n.SOI_ANCHOR_FOUND=11]="SOI_ANCHOR_FOUND",n[n.EMPTY_MATCH_PATTERN=12]="EMPTY_MATCH_PATTERN",n[n.NO_LINE_BREAKS_FLAGS=13]="NO_LINE_BREAKS_FLAGS",n[n.UNREACHABLE_PATTERN=14]="UNREACHABLE_PATTERN",n[n.IDENTIFY_TERMINATOR=15]="IDENTIFY_TERMINATOR",n[n.CUSTOM_LINE_BREAK=16]="CUSTOM_LINE_BREAK",n[n.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE=17]="MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"})(L||(L={}));const Me={deferDefinitionErrorsHandling:!1,positionTracking:"full",lineTerminatorsPattern:/\n|\r\n?/g,lineTerminatorCharacters:[`
`,"\r"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:Hs,traceInitPerf:!1,skipValidations:!1,recoveryEnabled:!0};Object.freeze(Me);class B{constructor(e,t=Me){if(this.lexerDefinition=e,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},this.TRACE_INIT=(r,i)=>{if(this.traceInitPerf===!0){this.traceInitIndent++;const o=new Array(this.traceInitIndent+1).join("	");this.traceInitIndent<this.traceInitMaxIdent&&console.log(`${o}--> <${r}>`);const{time:a,value:c}=mn(i),l=a>10?console.warn:console.log;return this.traceInitIndent<this.traceInitMaxIdent&&l(`${o}<-- <${r}> time: ${a}ms`),this.traceInitIndent--,c}else return i()},typeof t=="boolean")throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);this.config=It({},Me,t);const s=this.config.traceInitPerf;s===!0?(this.traceInitMaxIdent=1/0,this.traceInitPerf=!0):typeof s=="number"&&(this.traceInitMaxIdent=s,this.traceInitPerf=!0),this.traceInitIndent=-1,this.TRACE_INIT("Lexer Constructor",()=>{let r,i=!0;this.TRACE_INIT("Lexer Config handling",()=>{if(this.config.lineTerminatorsPattern===Me.lineTerminatorsPattern)this.config.lineTerminatorsPattern=Fs;else if(this.config.lineTerminatorCharacters===Me.lineTerminatorCharacters)throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);if(t.safeMode&&t.ensureOptimizations)throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking),K(e)?r={modes:{defaultMode:M(e)},defaultMode:Pe}:(i=!1,r=M(e))}),this.config.skipValidations===!1&&(this.TRACE_INIT("performRuntimeChecks",()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(Ps(r,this.trackStartLines,this.config.lineTerminatorCharacters))}),this.TRACE_INIT("performWarningRuntimeChecks",()=>{this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(ys(r,this.trackStartLines,this.config.lineTerminatorCharacters))})),r.modes=r.modes?r.modes:{},R(r.modes,(a,c)=>{r.modes[c]=nt(a,l=>te(l))});const o=Fe(r.modes);if(R(r.modes,(a,c)=>{this.TRACE_INIT(`Mode: <${c}> processing`,()=>{if(this.modes.push(c),this.config.skipValidations===!1&&this.TRACE_INIT("validatePatterns",()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(ms(a,o))}),O(this.lexerDefinitionErrors)){Ge(a);let l;this.TRACE_INIT("analyzeTokenTypes",()=>{l=fs(a,{lineTerminatorCharacters:this.config.lineTerminatorCharacters,positionTracking:t.positionTracking,ensureOptimizations:t.ensureOptimizations,safeMode:t.safeMode,tracer:this.TRACE_INIT})}),this.patternIdxToConfig[c]=l.patternIdxToConfig,this.charCodeToPatternIdxToConfig[c]=l.charCodeToPatternIdxToConfig,this.emptyGroups=It({},this.emptyGroups,l.emptyGroups),this.hasCustom=l.hasCustom||this.hasCustom,this.canModeBeOptimized[c]=l.canBeOptimized}})}),this.defaultMode=r.defaultMode,!O(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){const c=E(this.lexerDefinitionErrors,l=>l.message).join(`-----------------------
`);throw new Error(`Errors detected in definition of Lexer:
`+c)}R(this.lexerDefinitionWarning,a=>{fn(a.message)}),this.TRACE_INIT("Choosing sub-methods implementations",()=>{if(In?(this.chopInput=Bt,this.match=this.matchWithTest):(this.updateLastIndex=C,this.match=this.matchWithExec),i&&(this.handleModes=C),this.trackStartLines===!1&&(this.computeNewColumn=Bt),this.trackEndLines===!1&&(this.updateTokenEndLineColumnLocation=C),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else if(/onlyOffset/i.test(this.config.positionTracking))this.createTokenInstance=this.createOffsetOnlyToken;else throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);this.hasCustom?(this.addToken=this.addTokenUsingPush,this.handlePayload=this.handlePayloadWithCustom):(this.addToken=this.addTokenUsingMemberAccess,this.handlePayload=this.handlePayloadNoCustom)}),this.TRACE_INIT("Failed Optimization Warnings",()=>{const a=D(this.canModeBeOptimized,(c,l,h)=>(l===!1&&c.push(h),c),[]);if(t.ensureOptimizations&&!O(a))throw Error(`Lexer Modes: < ${a.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)}),this.TRACE_INIT("clearRegExpParserCache",()=>{ls()}),this.TRACE_INIT("toFastProperties",()=>{Tn(this)})})}tokenize(e,t=this.defaultMode){if(!O(this.lexerDefinitionErrors)){const r=E(this.lexerDefinitionErrors,i=>i.message).join(`-----------------------
`);throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
`+r)}return this.tokenizeInternal(e,t)}tokenizeInternal(e,t){let s,r,i,o,a,c,l,h,u,m,I,A,N,S,T;const f=e,d=f.length;let p=0,k=0;const H=this.hasCustom?0:Math.floor(e.length/10),se=new Array(H),ue=[];let _e=this.trackStartLines?1:void 0,re=this.trackStartLines?1:void 0;const ke=Ms(this.emptyGroups),zn=this.trackStartLines,ut=this.config.lineTerminatorsPattern;let $e=0,ie=[],Le=[];const Be=[],wt=[];Object.freeze(wt);let Ce;function bt(){return ie}function Ut(v){const G=ce(v),pe=Le[G];return pe===void 0?wt:pe}const Yn=v=>{if(Be.length===1&&v.tokenType.PUSH_MODE===void 0){const G=this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(v);ue.push({offset:v.startOffset,line:v.startLine,column:v.startColumn,length:v.image.length,message:G})}else{Be.pop();const G=ge(Be);ie=this.patternIdxToConfig[G],Le=this.charCodeToPatternIdxToConfig[G],$e=ie.length;const pe=this.canModeBeOptimized[G]&&this.config.safeMode===!1;Le&&pe?Ce=Ut:Ce=bt}};function Dt(v){Be.push(v),Le=this.charCodeToPatternIdxToConfig[v],ie=this.patternIdxToConfig[v],$e=ie.length,$e=ie.length;const G=this.canModeBeOptimized[v]&&this.config.safeMode===!1;Le&&G?Ce=Ut:Ce=bt}Dt.call(this,t);let V;const Gt=this.config.recoveryEnabled;for(;p<d;){c=null;const v=f.charCodeAt(p),G=Ce(v),pe=G.length;for(s=0;s<pe;s++){V=G[s];const U=V.pattern;l=null;const Q=V.short;if(Q!==!1?v===Q&&(c=U):V.isCustom===!0?(T=U.exec(f,p,se,ke),T!==null?(c=T[0],T.payload!==void 0&&(l=T.payload)):c=null):(this.updateLastIndex(U,p),c=this.match(U,e,p)),c!==null){if(a=V.longerAlt,a!==void 0){const oe=a.length;for(i=0;i<oe;i++){const Z=ie[a[i]],de=Z.pattern;if(h=null,Z.isCustom===!0?(T=de.exec(f,p,se,ke),T!==null?(o=T[0],T.payload!==void 0&&(h=T.payload)):o=null):(this.updateLastIndex(de,p),o=this.match(de,e,p)),o&&o.length>c.length){c=o,l=h,V=Z;break}}}break}}if(c!==null){if(u=c.length,m=V.group,m!==void 0&&(I=V.tokenTypeIdx,A=this.createTokenInstance(c,p,I,V.tokenType,_e,re,u),this.handlePayload(A,l),m===!1?k=this.addToken(se,k,A):ke[m].push(A)),e=this.chopInput(e,u),p=p+u,re=this.computeNewColumn(re,u),zn===!0&&V.canLineTerminator===!0){let U=0,Q,oe;ut.lastIndex=0;do Q=ut.test(c),Q===!0&&(oe=ut.lastIndex-1,U++);while(Q===!0);U!==0&&(_e=_e+U,re=u-oe,this.updateTokenEndLineColumnLocation(A,m,oe,U,_e,re,u))}this.handleModes(V,Yn,Dt,A)}else{const U=p,Q=_e,oe=re;let Z=Gt===!1;for(;Z===!1&&p<d;)for(e=this.chopInput(e,1),p++,r=0;r<$e;r++){const de=ie[r],dt=de.pattern,Kt=de.short;if(Kt!==!1?f.charCodeAt(p)===Kt&&(Z=!0):de.isCustom===!0?Z=dt.exec(f,p,se,ke)!==null:(this.updateLastIndex(dt,p),Z=dt.exec(e)!==null),Z===!0)break}if(N=p-U,re=this.computeNewColumn(re,N),S=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(f,U,N,Q,oe),ue.push({offset:U,line:Q,column:oe,length:N,message:S}),Gt===!1)break}}return this.hasCustom||(se.length=k),{tokens:se,groups:ke,errors:ue}}handleModes(e,t,s,r){if(e.pop===!0){const i=e.push;t(r),i!==void 0&&s.call(this,i)}else e.push!==void 0&&s.call(this,e.push)}chopInput(e,t){return e.substring(t)}updateLastIndex(e,t){e.lastIndex=t}updateTokenEndLineColumnLocation(e,t,s,r,i,o,a){let c,l;t!==void 0&&(c=s===a-1,l=c?-1:0,r===1&&c===!0||(e.endLine=i+l,e.endColumn=o-1+-l))}computeNewColumn(e,t){return e+t}createOffsetOnlyToken(e,t,s,r){return{image:e,startOffset:t,tokenTypeIdx:s,tokenType:r}}createStartOnlyToken(e,t,s,r,i,o){return{image:e,startOffset:t,startLine:i,startColumn:o,tokenTypeIdx:s,tokenType:r}}createFullToken(e,t,s,r,i,o,a){return{image:e,startOffset:t,endOffset:t+a-1,startLine:i,endLine:i,startColumn:o,endColumn:o+a-1,tokenTypeIdx:s,tokenType:r}}addTokenUsingPush(e,t,s){return e.push(s),t}addTokenUsingMemberAccess(e,t,s){return e[t]=s,t++,t}handlePayloadNoCustom(e,t){}handlePayloadWithCustom(e,t){t!==null&&(e.payload=t)}matchWithTest(e,t,s){return e.test(t)===!0?t.substring(s,e.lastIndex):null}matchWithExec(e,t){const s=e.exec(t);return s!==null?s[0]:null}}B.SKIPPED="This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";B.NA=/NOT_APPLICABLE/;function ve(n){return _n(n)?n.LABEL:n.name}function _n(n){return J(n.LABEL)&&n.LABEL!==""}const Vs="parent",jt="categories",qt="label",Jt="group",Qt="push_mode",Zt="pop_mode",en="longer_alt",tn="line_breaks",nn="start_chars_hint";function kn(n){return zs(n)}function zs(n){const e=n.pattern,t={};if(t.name=n.name,te(e)||(t.PATTERN=e),g(n,Vs))throw`The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;return g(n,jt)&&(t.CATEGORIES=n[jt]),Ge([t]),g(n,qt)&&(t.LABEL=n[qt]),g(n,Jt)&&(t.GROUP=n[Jt]),g(n,Zt)&&(t.POP_MODE=n[Zt]),g(n,Qt)&&(t.PUSH_MODE=n[Qt]),g(n,en)&&(t.LONGER_ALT=n[en]),g(n,tn)&&(t.LINE_BREAKS=n[tn]),g(n,nn)&&(t.START_CHARS_HINT=n[nn]),t}const Te=kn({name:"EOF",pattern:B.NA});Ge([Te]);function Mt(n,e,t,s,r,i,o,a){return{image:e,startOffset:t,endOffset:s,startLine:r,endLine:i,startColumn:o,endColumn:a,tokenTypeIdx:n.tokenTypeIdx,tokenType:n}}function Ys(n,e){return De(n,e)}const Ln={buildMismatchTokenMessage({expected:n,actual:e,previous:t,ruleName:s}){return`Expecting ${_n(n)?`--> ${ve(n)} <--`:`token of type --> ${n.name} <--`} but found --> '${e.image}' <--`},buildNotAllInputParsedMessage({firstRedundant:n,ruleName:e}){return"Redundant input, expecting EOF but found: "+n.image},buildNoViableAltMessage({expectedPathsPerAlt:n,actual:e,previous:t,customUserDescription:s,ruleName:r}){const i="Expecting: ",a=`
but found: '`+X(e).image+"'";if(s)return i+s+a;{const c=D(n,(m,I)=>m.concat(I),[]),l=E(c,m=>`[${E(m,I=>ve(I)).join(", ")}]`),u=`one of these possible Token sequences:
${E(l,(m,I)=>`  ${I+1}. ${m}`).join(`
`)}`;return i+u+a}},buildEarlyExitMessage({expectedIterationPaths:n,actual:e,customUserDescription:t,ruleName:s}){const r="Expecting: ",o=`
but found: '`+X(e).image+"'";if(t)return r+t+o;{const c=`expecting at least one iteration which starts with one of these possible Token sequences::
  <${E(n,l=>`[${E(l,h=>ve(h)).join(",")}]`).join(" ,")}>`;return r+c+o}}};Object.freeze(Ln);const Xs={buildRuleNotFoundError(n,e){return"Invalid grammar, reference to a rule which is not defined: ->"+e.nonTerminalName+`<-
inside top level rule: ->`+n.name+"<-"}},fe={buildDuplicateFoundError(n,e){function t(h){return h instanceof y?h.terminalType.name:h instanceof le?h.nonTerminalName:""}const s=n.name,r=X(e),i=r.idx,o=j(r),a=t(r),c=i>0;let l=`->${o}${c?i:""}<- ${a?`with argument: ->${a}<-`:""}
                  appears more than once (${e.length} times) in the top level rule: ->${s}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;return l=l.replace(/[ \t]+/g," "),l=l.replace(/\s\s+/g,`
`),l},buildNamespaceConflictError(n){return`Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${n.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`},buildAlternationPrefixAmbiguityError(n){const e=E(n.prefixPath,r=>ve(r)).join(", "),t=n.alternation.idx===0?"":n.alternation.idx;return`Ambiguous alternatives: <${n.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${t}> inside <${n.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`},buildAlternationAmbiguityError(n){const e=E(n.prefixPath,r=>ve(r)).join(", "),t=n.alternation.idx===0?"":n.alternation.idx;let s=`Ambiguous Alternatives Detected: <${n.ambiguityIndices.join(" ,")}> in <OR${t}> inside <${n.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;return s=s+`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`,s},buildEmptyRepetitionError(n){let e=j(n.repetition);return n.repetition.idx!==0&&(e+=n.repetition.idx),`The repetition <${e}> within Rule <${n.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`},buildTokenNameError(n){return"deprecated"},buildEmptyAlternationError(n){return`Ambiguous empty alternative: <${n.emptyChoiceIdx+1}> in <OR${n.alternation.idx}> inside <${n.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`},buildTooManyAlternativesError(n){return`An Alternation cannot have more than 256 alternatives:
<OR${n.alternation.idx}> inside <${n.topLevelRule.name}> Rule.
 has ${n.alternation.definition.length+1} alternatives.`},buildLeftRecursionError(n){const e=n.topLevelRule.name,t=E(n.leftRecursionPath,i=>i.name),s=`${e} --> ${t.concat([e]).join(" --> ")}`;return`Left Recursion found in grammar.
rule: <${e}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${s}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`},buildInvalidRuleNameError(n){return"deprecated"},buildDuplicateRuleNameError(n){let e;return n.topLevelRule instanceof Ct?e=n.topLevelRule.name:e=n.topLevelRule,`Duplicate definition, rule: ->${e}<- is already defined in the grammar: ->${n.grammarName}<-`}};function js(n,e){const t=new qs(n,e);return t.resolveRefs(),t.errors}class qs extends Oe{constructor(e,t){super(),this.nameToTopRule=e,this.errMsgProvider=t,this.errors=[]}resolveRefs(){R(x(this.nameToTopRule),e=>{this.currTopLevel=e,e.accept(this)})}visitNonTerminal(e){const t=this.nameToTopRule[e.nonTerminalName];if(t)e.referencedRule=t;else{const s=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,e);this.errors.push({message:s,type:F.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:e.nonTerminalName})}}}class Js extends rt{constructor(e,t){super(),this.topProd=e,this.path=t,this.possibleTokTypes=[],this.nextProductionName="",this.nextProductionOccurrence=0,this.found=!1,this.isAtEndOfPath=!1}startWalking(){if(this.found=!1,this.path.ruleStack[0]!==this.topProd.name)throw Error("The path does not start with the walker's top Rule!");return this.ruleStack=M(this.path.ruleStack).reverse(),this.occurrenceStack=M(this.path.occurrenceStack).reverse(),this.ruleStack.pop(),this.occurrenceStack.pop(),this.updateExpectedNext(),this.walk(this.topProd),this.possibleTokTypes}walk(e,t=[]){this.found||super.walk(e,t)}walkProdRef(e,t,s){if(e.referencedRule.name===this.nextProductionName&&e.idx===this.nextProductionOccurrence){const r=t.concat(s);this.updateExpectedNext(),this.walk(e.referencedRule,r)}}updateExpectedNext(){O(this.ruleStack)?(this.nextProductionName="",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop())}}class Qs extends Js{constructor(e,t){super(e,t),this.path=t,this.nextTerminalName="",this.nextTerminalOccurrence=0,this.nextTerminalName=this.path.lastTok.name,this.nextTerminalOccurrence=this.path.lastTokOccurrence}walkTerminal(e,t,s){if(this.isAtEndOfPath&&e.terminalType.name===this.nextTerminalName&&e.idx===this.nextTerminalOccurrence&&!this.found){const r=t.concat(s),i=new Y({definition:r});this.possibleTokTypes=Ue(i),this.found=!0}}}class ot extends rt{constructor(e,t){super(),this.topRule=e,this.occurrence=t,this.result={token:void 0,occurrence:void 0,isEndOfRule:void 0}}startWalking(){return this.walk(this.topRule),this.result}}class Zs extends ot{walkMany(e,t,s){if(e.idx===this.occurrence){const r=X(t.concat(s));this.result.isEndOfRule=r===void 0,r instanceof y&&(this.result.token=r.terminalType,this.result.occurrence=r.idx)}else super.walkMany(e,t,s)}}class sn extends ot{walkManySep(e,t,s){if(e.idx===this.occurrence){const r=X(t.concat(s));this.result.isEndOfRule=r===void 0,r instanceof y&&(this.result.token=r.terminalType,this.result.occurrence=r.idx)}else super.walkManySep(e,t,s)}}class er extends ot{walkAtLeastOne(e,t,s){if(e.idx===this.occurrence){const r=X(t.concat(s));this.result.isEndOfRule=r===void 0,r instanceof y&&(this.result.token=r.terminalType,this.result.occurrence=r.idx)}else super.walkAtLeastOne(e,t,s)}}class rn extends ot{walkAtLeastOneSep(e,t,s){if(e.idx===this.occurrence){const r=X(t.concat(s));this.result.isEndOfRule=r===void 0,r instanceof y&&(this.result.token=r.terminalType,this.result.occurrence=r.idx)}else super.walkAtLeastOneSep(e,t,s)}}function At(n,e,t=[]){t=M(t);let s=[],r=0;function i(a){return a.concat(P(n,r+1))}function o(a){const c=At(i(a),e,t);return s.concat(c)}for(;t.length<e&&r<n.length;){const a=n[r];if(a instanceof Y)return o(a.definition);if(a instanceof le)return o(a.definition);if(a instanceof ee)s=o(a.definition);else if(a instanceof Re){const c=a.definition.concat([new w({definition:a.definition})]);return o(c)}else if(a instanceof Ae){const c=[new Y({definition:a.definition}),new w({definition:[new y({terminalType:a.separator})].concat(a.definition)})];return o(c)}else if(a instanceof Ne){const c=a.definition.concat([new w({definition:[new y({terminalType:a.separator})].concat(a.definition)})]);s=o(c)}else if(a instanceof w){const c=a.definition.concat([new w({definition:a.definition})]);s=o(c)}else{if(a instanceof Se)return R(a.definition,c=>{O(c.definition)===!1&&(s=o(c.definition))}),s;if(a instanceof y)t.push(a.terminalType);else throw Error("non exhaustive match")}r++}return s.push({partialPath:t,suffixDef:P(n,r)}),s}function Cn(n,e,t,s){const r="EXIT_NONE_TERMINAL",i=[r],o="EXIT_ALTERNATIVE";let a=!1;const c=e.length,l=c-s-1,h=[],u=[];for(u.push({idx:-1,def:n,ruleStack:[],occurrenceStack:[]});!O(u);){const m=u.pop();if(m===o){a&&ge(u).idx<=l&&u.pop();continue}const I=m.def,A=m.idx,N=m.ruleStack,S=m.occurrenceStack;if(O(I))continue;const T=I[0];if(T===r){const f={idx:A,def:P(I),ruleStack:we(N),occurrenceStack:we(S)};u.push(f)}else if(T instanceof y)if(A<c-1){const f=A+1,d=e[f];if(t(d,T.terminalType)){const p={idx:f,def:P(I),ruleStack:N,occurrenceStack:S};u.push(p)}}else if(A===c-1)h.push({nextTokenType:T.terminalType,nextTokenOccurrence:T.idx,ruleStack:N,occurrenceStack:S}),a=!0;else throw Error("non exhaustive match");else if(T instanceof le){const f=M(N);f.push(T.nonTerminalName);const d=M(S);d.push(T.idx);const p={idx:A,def:T.definition.concat(i,P(I)),ruleStack:f,occurrenceStack:d};u.push(p)}else if(T instanceof ee){const f={idx:A,def:P(I),ruleStack:N,occurrenceStack:S};u.push(f),u.push(o);const d={idx:A,def:T.definition.concat(P(I)),ruleStack:N,occurrenceStack:S};u.push(d)}else if(T instanceof Re){const f=new w({definition:T.definition,idx:T.idx}),d=T.definition.concat([f],P(I)),p={idx:A,def:d,ruleStack:N,occurrenceStack:S};u.push(p)}else if(T instanceof Ae){const f=new y({terminalType:T.separator}),d=new w({definition:[f].concat(T.definition),idx:T.idx}),p=T.definition.concat([d],P(I)),k={idx:A,def:p,ruleStack:N,occurrenceStack:S};u.push(k)}else if(T instanceof Ne){const f={idx:A,def:P(I),ruleStack:N,occurrenceStack:S};u.push(f),u.push(o);const d=new y({terminalType:T.separator}),p=new w({definition:[d].concat(T.definition),idx:T.idx}),k=T.definition.concat([p],P(I)),H={idx:A,def:k,ruleStack:N,occurrenceStack:S};u.push(H)}else if(T instanceof w){const f={idx:A,def:P(I),ruleStack:N,occurrenceStack:S};u.push(f),u.push(o);const d=new w({definition:T.definition,idx:T.idx}),p=T.definition.concat([d],P(I)),k={idx:A,def:p,ruleStack:N,occurrenceStack:S};u.push(k)}else if(T instanceof Se)for(let f=T.definition.length-1;f>=0;f--){const d=T.definition[f],p={idx:A,def:d.definition.concat(P(I)),ruleStack:N,occurrenceStack:S};u.push(p),u.push(o)}else if(T instanceof Y)u.push({idx:A,def:T.definition.concat(P(I)),ruleStack:N,occurrenceStack:S});else if(T instanceof Ct)u.push(tr(T,A,N,S));else throw Error("non exhaustive match")}return h}function tr(n,e,t,s){const r=M(t);r.push(n.name);const i=M(s);return i.push(1),{idx:e,def:n.definition,ruleStack:r,occurrenceStack:i}}var _;(function(n){n[n.OPTION=0]="OPTION",n[n.REPETITION=1]="REPETITION",n[n.REPETITION_MANDATORY=2]="REPETITION_MANDATORY",n[n.REPETITION_MANDATORY_WITH_SEPARATOR=3]="REPETITION_MANDATORY_WITH_SEPARATOR",n[n.REPETITION_WITH_SEPARATOR=4]="REPETITION_WITH_SEPARATOR",n[n.ALTERNATION=5]="ALTERNATION"})(_||(_={}));function vt(n){if(n instanceof ee||n==="Option")return _.OPTION;if(n instanceof w||n==="Repetition")return _.REPETITION;if(n instanceof Re||n==="RepetitionMandatory")return _.REPETITION_MANDATORY;if(n instanceof Ae||n==="RepetitionMandatoryWithSeparator")return _.REPETITION_MANDATORY_WITH_SEPARATOR;if(n instanceof Ne||n==="RepetitionWithSeparator")return _.REPETITION_WITH_SEPARATOR;if(n instanceof Se||n==="Alternation")return _.ALTERNATION;throw Error("non exhaustive match")}function ri(n){const{occurrence:e,rule:t,prodType:s,maxLookahead:r}=n,i=vt(s);return i===_.ALTERNATION?at(e,t,r):ct(e,t,i,r)}function nr(n,e,t,s,r,i){const o=at(n,e,t),a=yn(o)?Je:De;return i(o,s,a,r)}function sr(n,e,t,s,r,i){const o=ct(n,e,r,t),a=yn(o)?Je:De;return i(o[0],a,s)}function rr(n,e,t,s){const r=n.length,i=q(n,o=>q(o,a=>a.length===1));if(e)return function(o){const a=E(o,c=>c.GATE);for(let c=0;c<r;c++){const l=n[c],h=l.length,u=a[c];if(!(u!==void 0&&u.call(this)===!1))e:for(let m=0;m<h;m++){const I=l[m],A=I.length;for(let N=0;N<A;N++){const S=this.LA(N+1);if(t(S,I[N])===!1)continue e}return c}}};if(i&&!s){const o=E(n,c=>z(c)),a=D(o,(c,l,h)=>(R(l,u=>{g(c,u.tokenTypeIdx)||(c[u.tokenTypeIdx]=h),R(u.categoryMatches,m=>{g(c,m)||(c[m]=h)})}),c),{});return function(){const c=this.LA(1);return a[c.tokenTypeIdx]}}else return function(){for(let o=0;o<r;o++){const a=n[o],c=a.length;e:for(let l=0;l<c;l++){const h=a[l],u=h.length;for(let m=0;m<u;m++){const I=this.LA(m+1);if(t(I,h[m])===!1)continue e}return o}}}}function ir(n,e,t){const s=q(n,i=>i.length===1),r=n.length;if(s&&!t){const i=z(n);if(i.length===1&&O(i[0].categoryMatches)){const a=i[0].tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===a}}else{const o=D(i,(a,c,l)=>(a[c.tokenTypeIdx]=!0,R(c.categoryMatches,h=>{a[h]=!0}),a),[]);return function(){const a=this.LA(1);return o[a.tokenTypeIdx]===!0}}}else return function(){e:for(let i=0;i<r;i++){const o=n[i],a=o.length;for(let c=0;c<a;c++){const l=this.LA(c+1);if(e(l,o[c])===!1)continue e}return!0}return!1}}class or extends rt{constructor(e,t,s){super(),this.topProd=e,this.targetOccurrence=t,this.targetProdType=s}startWalking(){return this.walk(this.topProd),this.restDef}checkIsTarget(e,t,s,r){return e.idx===this.targetOccurrence&&this.targetProdType===t?(this.restDef=s.concat(r),!0):!1}walkOption(e,t,s){this.checkIsTarget(e,_.OPTION,t,s)||super.walkOption(e,t,s)}walkAtLeastOne(e,t,s){this.checkIsTarget(e,_.REPETITION_MANDATORY,t,s)||super.walkOption(e,t,s)}walkAtLeastOneSep(e,t,s){this.checkIsTarget(e,_.REPETITION_MANDATORY_WITH_SEPARATOR,t,s)||super.walkOption(e,t,s)}walkMany(e,t,s){this.checkIsTarget(e,_.REPETITION,t,s)||super.walkOption(e,t,s)}walkManySep(e,t,s){this.checkIsTarget(e,_.REPETITION_WITH_SEPARATOR,t,s)||super.walkOption(e,t,s)}}class xn extends Oe{constructor(e,t,s){super(),this.targetOccurrence=e,this.targetProdType=t,this.targetRef=s,this.result=[]}checkIsTarget(e,t){e.idx===this.targetOccurrence&&this.targetProdType===t&&(this.targetRef===void 0||e===this.targetRef)&&(this.result=e.definition)}visitOption(e){this.checkIsTarget(e,_.OPTION)}visitRepetition(e){this.checkIsTarget(e,_.REPETITION)}visitRepetitionMandatory(e){this.checkIsTarget(e,_.REPETITION_MANDATORY)}visitRepetitionMandatoryWithSeparator(e){this.checkIsTarget(e,_.REPETITION_MANDATORY_WITH_SEPARATOR)}visitRepetitionWithSeparator(e){this.checkIsTarget(e,_.REPETITION_WITH_SEPARATOR)}visitAlternation(e){this.checkIsTarget(e,_.ALTERNATION)}}function on(n){const e=new Array(n);for(let t=0;t<n;t++)e[t]=[];return e}function mt(n){let e=[""];for(let t=0;t<n.length;t++){const s=n[t],r=[];for(let i=0;i<e.length;i++){const o=e[i];r.push(o+"_"+s.tokenTypeIdx);for(let a=0;a<s.categoryMatches.length;a++){const c="_"+s.categoryMatches[a];r.push(o+c)}}e=r}return e}function ar(n,e,t){for(let s=0;s<n.length;s++){if(s===t)continue;const r=n[s];for(let i=0;i<e.length;i++){const o=e[i];if(r[o]===!0)return!1}}return!0}function Pn(n,e){const t=E(n,o=>At([o],1)),s=on(t.length),r=E(t,o=>{const a={};return R(o,c=>{const l=mt(c.partialPath);R(l,h=>{a[h]=!0})}),a});let i=t;for(let o=1;o<=e;o++){const a=i;i=on(a.length);for(let c=0;c<a.length;c++){const l=a[c];for(let h=0;h<l.length;h++){const u=l[h].partialPath,m=l[h].suffixDef,I=mt(u);if(ar(r,I,c)||O(m)||u.length===e){const N=s[c];if(Nt(N,u)===!1){N.push(u);for(let S=0;S<I.length;S++){const T=I[S];r[c][T]=!0}}}else{const N=At(m,o+1,u);i[c]=i[c].concat(N),R(N,S=>{const T=mt(S.partialPath);R(T,f=>{r[c][f]=!0})})}}}}return s}function at(n,e,t,s){const r=new xn(n,_.ALTERNATION,s);return e.accept(r),Pn(r.result,t)}function ct(n,e,t,s){const r=new xn(n,t);e.accept(r);const i=r.result,a=new or(e,n,t).startWalking(),c=new Y({definition:i}),l=new Y({definition:a});return Pn([c,l],s)}function Nt(n,e){e:for(let t=0;t<n.length;t++){const s=n[t];if(s.length===e.length){for(let r=0;r<s.length;r++){const i=e[r],o=s[r];if((i===o||o.categoryMatchesMap[i.tokenTypeIdx]!==void 0)===!1)continue e}return!0}}return!1}function cr(n,e){return n.length<e.length&&q(n,(t,s)=>{const r=e[s];return t===r||r.categoryMatchesMap[t.tokenTypeIdx]})}function yn(n){return q(n,e=>q(e,t=>q(t,s=>O(s.categoryMatches))))}function lr(n){const e=n.lookaheadStrategy.validate({rules:n.rules,tokenTypes:n.tokenTypes,grammarName:n.grammarName});return E(e,t=>Object.assign({type:F.CUSTOM_LOOKAHEAD_VALIDATION},t))}function hr(n,e,t,s){const r=$(n,c=>ur(c,t)),i=Sr(n,e,t),o=$(n,c=>gr(c,t)),a=$(n,c=>mr(c,n,s,t));return r.concat(i,o,a)}function ur(n,e){const t=new fr;n.accept(t);const s=t.allProductions,r=Qn(s,dr),i=Zn(r,a=>a.length>1);return E(x(i),a=>{const c=X(a),l=e.buildDuplicateFoundError(n,a),h=j(c),u={message:l,type:F.DUPLICATE_PRODUCTIONS,ruleName:n.name,dslName:h,occurrence:c.idx},m=Mn(c);return m&&(u.parameter=m),u})}function dr(n){return`${j(n)}_#_${n.idx}_#_${Mn(n)}`}function Mn(n){return n instanceof y?n.terminalType.name:n instanceof le?n.nonTerminalName:""}class fr extends Oe{constructor(){super(...arguments),this.allProductions=[]}visitNonTerminal(e){this.allProductions.push(e)}visitOption(e){this.allProductions.push(e)}visitRepetitionWithSeparator(e){this.allProductions.push(e)}visitRepetitionMandatory(e){this.allProductions.push(e)}visitRepetitionMandatoryWithSeparator(e){this.allProductions.push(e)}visitRepetition(e){this.allProductions.push(e)}visitAlternation(e){this.allProductions.push(e)}visitTerminal(e){this.allProductions.push(e)}}function mr(n,e,t,s){const r=[];if(D(e,(o,a)=>a.name===n.name?o+1:o,0)>1){const o=s.buildDuplicateRuleNameError({topLevelRule:n,grammarName:t});r.push({message:o,type:F.DUPLICATE_RULE_NAME,ruleName:n.name})}return r}function Tr(n,e,t){const s=[];let r;return b(e,n)||(r=`Invalid rule override, rule: ->${n}<- cannot be overridden in the grammar: ->${t}<-as it is not defined in any of the super grammars `,s.push({message:r,type:F.INVALID_RULE_OVERRIDE,ruleName:n})),s}function vn(n,e,t,s=[]){const r=[],i=Xe(e.definition);if(O(i))return[];{const o=n.name;b(i,n)&&r.push({message:t.buildLeftRecursionError({topLevelRule:n,leftRecursionPath:s}),type:F.LEFT_RECURSION,ruleName:o});const c=st(i,s.concat([n])),l=$(c,h=>{const u=M(s);return u.push(h),vn(n,h,t,u)});return r.concat(l)}}function Xe(n){let e=[];if(O(n))return e;const t=X(n);if(t instanceof le)e.push(t.referencedRule);else if(t instanceof Y||t instanceof ee||t instanceof Re||t instanceof Ae||t instanceof Ne||t instanceof w)e=e.concat(Xe(t.definition));else if(t instanceof Se)e=z(E(t.definition,i=>Xe(i.definition)));else if(!(t instanceof y))throw Error("non exhaustive match");const s=dn(t),r=n.length>1;if(s&&r){const i=P(n);return e.concat(Xe(i))}else return e}class Ft extends Oe{constructor(){super(...arguments),this.alternations=[]}visitAlternation(e){this.alternations.push(e)}}function Er(n,e){const t=new Ft;n.accept(t);const s=t.alternations;return $(s,i=>{const o=we(i.definition);return $(o,(a,c)=>{const l=Cn([a],[],De,1);return O(l)?[{message:e.buildEmptyAlternationError({topLevelRule:n,alternation:i,emptyChoiceIdx:c}),type:F.NONE_LAST_EMPTY_ALT,ruleName:n.name,occurrence:i.idx,alternative:c+1}]:[]})})}function pr(n,e,t){const s=new Ft;n.accept(s);let r=s.alternations;return r=nt(r,o=>o.ignoreAmbiguities===!0),$(r,o=>{const a=o.idx,c=o.maxLookahead||e,l=at(a,n,c,o),h=Ar(l,o,n,t),u=Nr(l,o,n,t);return h.concat(u)})}class Ir extends Oe{constructor(){super(...arguments),this.allProductions=[]}visitRepetitionWithSeparator(e){this.allProductions.push(e)}visitRepetitionMandatory(e){this.allProductions.push(e)}visitRepetitionMandatoryWithSeparator(e){this.allProductions.push(e)}visitRepetition(e){this.allProductions.push(e)}}function gr(n,e){const t=new Ft;n.accept(t);const s=t.alternations;return $(s,i=>i.definition.length>255?[{message:e.buildTooManyAlternativesError({topLevelRule:n,alternation:i}),type:F.TOO_MANY_ALTS,ruleName:n.name,occurrence:i.idx}]:[])}function Rr(n,e,t){const s=[];return R(n,r=>{const i=new Ir;r.accept(i);const o=i.allProductions;R(o,a=>{const c=vt(a),l=a.maxLookahead||e,h=a.idx,m=ct(h,r,c,l)[0];if(O(z(m))){const I=t.buildEmptyRepetitionError({topLevelRule:r,repetition:a});s.push({message:I,type:F.NO_NON_EMPTY_LOOKAHEAD,ruleName:r.name})}})}),s}function Ar(n,e,t,s){const r=[],i=D(n,(a,c,l)=>(e.definition[l].ignoreAmbiguities===!0||R(c,h=>{const u=[l];R(n,(m,I)=>{l!==I&&Nt(m,h)&&e.definition[I].ignoreAmbiguities!==!0&&u.push(I)}),u.length>1&&!Nt(r,h)&&(r.push(h),a.push({alts:u,path:h}))}),a),[]);return E(i,a=>{const c=E(a.alts,h=>h+1);return{message:s.buildAlternationAmbiguityError({topLevelRule:t,alternation:e,ambiguityIndices:c,prefixPath:a.path}),type:F.AMBIGUOUS_ALTS,ruleName:t.name,occurrence:e.idx,alternatives:a.alts}})}function Nr(n,e,t,s){const r=D(n,(o,a,c)=>{const l=E(a,h=>({idx:c,path:h}));return o.concat(l)},[]);return be($(r,o=>{if(e.definition[o.idx].ignoreAmbiguities===!0)return[];const c=o.idx,l=o.path,h=W(r,m=>e.definition[m.idx].ignoreAmbiguities!==!0&&m.idx<c&&cr(m.path,l));return E(h,m=>{const I=[m.idx+1,c+1],A=e.idx===0?"":e.idx;return{message:s.buildAlternationPrefixAmbiguityError({topLevelRule:t,alternation:e,ambiguityIndices:I,prefixPath:m.path}),type:F.AMBIGUOUS_PREFIX_ALTS,ruleName:t.name,occurrence:A,alternatives:I}})}))}function Sr(n,e,t){const s=[],r=E(e,i=>i.name);return R(n,i=>{const o=i.name;if(b(r,o)){const a=t.buildNamespaceConflictError(i);s.push({message:a,type:F.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:o})}}),s}function Or(n){const e=Pt(n,{errMsgProvider:Xs}),t={};return R(n.rules,s=>{t[s.name]=s}),js(t,e.errMsgProvider)}function _r(n){return n=Pt(n,{errMsgProvider:fe}),hr(n.rules,n.tokenTypes,n.errMsgProvider,n.grammarName)}const Fn="MismatchedTokenException",wn="NoViableAltException",bn="EarlyExitException",Un="NotAllInputParsedException",Dn=[Fn,wn,bn,Un];Object.freeze(Dn);function Qe(n){return b(Dn,n.name)}class lt extends Error{constructor(e,t){super(e),this.token=t,this.resyncedTokens=[],Object.setPrototypeOf(this,new.target.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}class Gn extends lt{constructor(e,t,s){super(e,t),this.previousToken=s,this.name=Fn}}class kr extends lt{constructor(e,t,s){super(e,t),this.previousToken=s,this.name=wn}}class Lr extends lt{constructor(e,t){super(e,t),this.name=Un}}class Cr extends lt{constructor(e,t,s){super(e,t),this.previousToken=s,this.name=bn}}const Tt={},Kn="InRuleRecoveryException";class xr extends Error{constructor(e){super(e),this.name=Kn}}class Pr{initRecoverable(e){this.firstAfterRepMap={},this.resyncFollows={},this.recoveryEnabled=g(e,"recoveryEnabled")?e.recoveryEnabled:ne.recoveryEnabled,this.recoveryEnabled&&(this.attemptInRepetitionRecovery=yr)}getTokenToInsert(e){const t=Mt(e,"",NaN,NaN,NaN,NaN,NaN,NaN);return t.isInsertedInRecovery=!0,t}canTokenTypeBeInsertedInRecovery(e){return!0}canTokenTypeBeDeletedInRecovery(e){return!0}tryInRepetitionRecovery(e,t,s,r){const i=this.findReSyncTokenType(),o=this.exportLexerState(),a=[];let c=!1;const l=this.LA(1);let h=this.LA(1);const u=()=>{const m=this.LA(0),I=this.errorMessageProvider.buildMismatchTokenMessage({expected:r,actual:l,previous:m,ruleName:this.getCurrRuleFullName()}),A=new Gn(I,l,this.LA(0));A.resyncedTokens=we(a),this.SAVE_ERROR(A)};for(;!c;)if(this.tokenMatcher(h,r)){u();return}else if(s.call(this)){u(),e.apply(this,t);return}else this.tokenMatcher(h,i)?c=!0:(h=this.SKIP_TOKEN(),this.addToResyncTokens(h,a));this.importLexerState(o)}shouldInRepetitionRecoveryBeTried(e,t,s){return!(s===!1||this.tokenMatcher(this.LA(1),e)||this.isBackTracking()||this.canPerformInRuleRecovery(e,this.getFollowsForInRuleRecovery(e,t)))}getFollowsForInRuleRecovery(e,t){const s=this.getCurrentGrammarPath(e,t);return this.getNextPossibleTokenTypes(s)}tryInRuleRecovery(e,t){if(this.canRecoverWithSingleTokenInsertion(e,t))return this.getTokenToInsert(e);if(this.canRecoverWithSingleTokenDeletion(e)){const s=this.SKIP_TOKEN();return this.consumeToken(),s}throw new xr("sad sad panda")}canPerformInRuleRecovery(e,t){return this.canRecoverWithSingleTokenInsertion(e,t)||this.canRecoverWithSingleTokenDeletion(e)}canRecoverWithSingleTokenInsertion(e,t){if(!this.canTokenTypeBeInsertedInRecovery(e)||O(t))return!1;const s=this.LA(1);return Ie(t,i=>this.tokenMatcher(s,i))!==void 0}canRecoverWithSingleTokenDeletion(e){return this.canTokenTypeBeDeletedInRecovery(e)?this.tokenMatcher(this.LA(2),e):!1}isInCurrentRuleReSyncSet(e){const t=this.getCurrFollowKey(),s=this.getFollowSetFromFollowKey(t);return b(s,e)}findReSyncTokenType(){const e=this.flattenFollowSet();let t=this.LA(1),s=2;for(;;){const r=Ie(e,i=>Ys(t,i));if(r!==void 0)return r;t=this.LA(s),s++}}getCurrFollowKey(){if(this.RULE_STACK.length===1)return Tt;const e=this.getLastExplicitRuleShortName(),t=this.getLastExplicitRuleOccurrenceIndex(),s=this.getPreviousExplicitRuleShortName();return{ruleName:this.shortRuleNameToFullName(e),idxInCallingRule:t,inRule:this.shortRuleNameToFullName(s)}}buildFullFollowKeyStack(){const e=this.RULE_STACK,t=this.RULE_OCCURRENCE_STACK;return E(e,(s,r)=>r===0?Tt:{ruleName:this.shortRuleNameToFullName(s),idxInCallingRule:t[r],inRule:this.shortRuleNameToFullName(e[r-1])})}flattenFollowSet(){const e=E(this.buildFullFollowKeyStack(),t=>this.getFollowSetFromFollowKey(t));return z(e)}getFollowSetFromFollowKey(e){if(e===Tt)return[Te];const t=e.ruleName+e.idxInCallingRule+En+e.inRule;return this.resyncFollows[t]}addToResyncTokens(e,t){return this.tokenMatcher(e,Te)||t.push(e),t}reSyncTo(e){const t=[];let s=this.LA(1);for(;this.tokenMatcher(s,e)===!1;)s=this.SKIP_TOKEN(),this.addToResyncTokens(s,t);return we(t)}attemptInRepetitionRecovery(e,t,s,r,i,o,a){}getCurrentGrammarPath(e,t){const s=this.getHumanReadableRuleStack(),r=M(this.RULE_OCCURRENCE_STACK);return{ruleStack:s,occurrenceStack:r,lastTok:e,lastTokOccurrence:t}}getHumanReadableRuleStack(){return E(this.RULE_STACK,e=>this.shortRuleNameToFullName(e))}}function yr(n,e,t,s,r,i,o){const a=this.getKeyForAutomaticLookahead(s,r);let c=this.firstAfterRepMap[a];if(c===void 0){const m=this.getCurrRuleFullName(),I=this.getGAstProductions()[m];c=new i(I,r).startWalking(),this.firstAfterRepMap[a]=c}let l=c.token,h=c.occurrence;const u=c.isEndOfRule;this.RULE_STACK.length===1&&u&&l===void 0&&(l=Te,h=1),!(l===void 0||h===void 0)&&this.shouldInRepetitionRecoveryBeTried(l,h,o)&&this.tryInRepetitionRecovery(n,e,t,l)}const Mr=4,he=8,$n=1<<he,Bn=2<<he,St=3<<he,Ot=4<<he,_t=5<<he,je=6<<he;function Et(n,e,t){return t|e|n}class vr{constructor(e){var t;this.maxLookahead=(t=e==null?void 0:e.maxLookahead)!==null&&t!==void 0?t:ne.maxLookahead}validate(e){const t=this.validateNoLeftRecursion(e.rules);if(O(t)){const s=this.validateEmptyOrAlternatives(e.rules),r=this.validateAmbiguousAlternationAlternatives(e.rules,this.maxLookahead),i=this.validateSomeNonEmptyLookaheadPath(e.rules,this.maxLookahead);return[...t,...s,...r,...i]}return t}validateNoLeftRecursion(e){return $(e,t=>vn(t,t,fe))}validateEmptyOrAlternatives(e){return $(e,t=>Er(t,fe))}validateAmbiguousAlternationAlternatives(e,t){return $(e,s=>pr(s,t,fe))}validateSomeNonEmptyLookaheadPath(e,t){return Rr(e,t,fe)}buildLookaheadForAlternation(e){return nr(e.prodOccurrence,e.rule,e.maxLookahead,e.hasPredicates,e.dynamicTokensEnabled,rr)}buildLookaheadForOptional(e){return sr(e.prodOccurrence,e.rule,e.maxLookahead,e.dynamicTokensEnabled,vt(e.prodType),ir)}}class Fr{initLooksAhead(e){this.dynamicTokensEnabled=g(e,"dynamicTokensEnabled")?e.dynamicTokensEnabled:ne.dynamicTokensEnabled,this.maxLookahead=g(e,"maxLookahead")?e.maxLookahead:ne.maxLookahead,this.lookaheadStrategy=g(e,"lookaheadStrategy")?e.lookaheadStrategy:new vr({maxLookahead:this.maxLookahead}),this.lookAheadFuncsCache=new Map}preComputeLookaheadFunctions(e){R(e,t=>{this.TRACE_INIT(`${t.name} Rule Lookahead`,()=>{const{alternation:s,repetition:r,option:i,repetitionMandatory:o,repetitionMandatoryWithSeparator:a,repetitionWithSeparator:c}=br(t);R(s,l=>{const h=l.idx===0?"":l.idx;this.TRACE_INIT(`${j(l)}${h}`,()=>{const u=this.lookaheadStrategy.buildLookaheadForAlternation({prodOccurrence:l.idx,rule:t,maxLookahead:l.maxLookahead||this.maxLookahead,hasPredicates:l.hasPredicates,dynamicTokensEnabled:this.dynamicTokensEnabled}),m=Et(this.fullRuleNameToShort[t.name],$n,l.idx);this.setLaFuncCache(m,u)})}),R(r,l=>{this.computeLookaheadFunc(t,l.idx,St,"Repetition",l.maxLookahead,j(l))}),R(i,l=>{this.computeLookaheadFunc(t,l.idx,Bn,"Option",l.maxLookahead,j(l))}),R(o,l=>{this.computeLookaheadFunc(t,l.idx,Ot,"RepetitionMandatory",l.maxLookahead,j(l))}),R(a,l=>{this.computeLookaheadFunc(t,l.idx,je,"RepetitionMandatoryWithSeparator",l.maxLookahead,j(l))}),R(c,l=>{this.computeLookaheadFunc(t,l.idx,_t,"RepetitionWithSeparator",l.maxLookahead,j(l))})})})}computeLookaheadFunc(e,t,s,r,i,o){this.TRACE_INIT(`${o}${t===0?"":t}`,()=>{const a=this.lookaheadStrategy.buildLookaheadForOptional({prodOccurrence:t,rule:e,maxLookahead:i||this.maxLookahead,dynamicTokensEnabled:this.dynamicTokensEnabled,prodType:r}),c=Et(this.fullRuleNameToShort[e.name],s,t);this.setLaFuncCache(c,a)})}getKeyForAutomaticLookahead(e,t){const s=this.getLastExplicitRuleShortName();return Et(s,e,t)}getLaFuncFromCache(e){return this.lookAheadFuncsCache.get(e)}setLaFuncCache(e,t){this.lookAheadFuncsCache.set(e,t)}}class wr extends Oe{constructor(){super(...arguments),this.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]}}reset(){this.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]}}visitOption(e){this.dslMethods.option.push(e)}visitRepetitionWithSeparator(e){this.dslMethods.repetitionWithSeparator.push(e)}visitRepetitionMandatory(e){this.dslMethods.repetitionMandatory.push(e)}visitRepetitionMandatoryWithSeparator(e){this.dslMethods.repetitionMandatoryWithSeparator.push(e)}visitRepetition(e){this.dslMethods.repetition.push(e)}visitAlternation(e){this.dslMethods.alternation.push(e)}}const Ve=new wr;function br(n){Ve.reset(),n.accept(Ve);const e=Ve.dslMethods;return Ve.reset(),e}function an(n,e){isNaN(n.startOffset)===!0?(n.startOffset=e.startOffset,n.endOffset=e.endOffset):n.endOffset<e.endOffset&&(n.endOffset=e.endOffset)}function cn(n,e){isNaN(n.startOffset)===!0?(n.startOffset=e.startOffset,n.startColumn=e.startColumn,n.startLine=e.startLine,n.endOffset=e.endOffset,n.endColumn=e.endColumn,n.endLine=e.endLine):n.endOffset<e.endOffset&&(n.endOffset=e.endOffset,n.endColumn=e.endColumn,n.endLine=e.endLine)}function Ur(n,e,t){n.children[t]===void 0?n.children[t]=[e]:n.children[t].push(e)}function Dr(n,e,t){n.children[e]===void 0?n.children[e]=[t]:n.children[e].push(t)}const Gr="name";function Wn(n,e){Object.defineProperty(n,Gr,{enumerable:!1,configurable:!0,writable:!1,value:e})}function Kr(n,e){const t=Fe(n),s=t.length;for(let r=0;r<s;r++){const i=t[r],o=n[i],a=o.length;for(let c=0;c<a;c++){const l=o[c];l.tokenTypeIdx===void 0&&this[l.name](l.children,e)}}}function $r(n,e){const t=function(){};Wn(t,n+"BaseSemantics");const s={visit:function(r,i){if(K(r)&&(r=r[0]),!te(r))return this[r.name](r.children,i)},validateVisitor:function(){const r=Wr(this,e);if(!O(r)){const i=E(r,o=>o.msg);throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${i.join(`

`).replace(/\n/g,`
	`)}`)}}};return t.prototype=s,t.prototype.constructor=t,t._RULE_NAMES=e,t}function Br(n,e,t){const s=function(){};Wn(s,n+"BaseSemanticsWithDefaults");const r=Object.create(t.prototype);return R(e,i=>{r[i]=Kr}),s.prototype=r,s.prototype.constructor=s,s}var kt;(function(n){n[n.REDUNDANT_METHOD=0]="REDUNDANT_METHOD",n[n.MISSING_METHOD=1]="MISSING_METHOD"})(kt||(kt={}));function Wr(n,e){return Hr(n,e)}function Hr(n,e){const t=W(e,r=>Ee(n[r])===!1),s=E(t,r=>({msg:`Missing visitor method: <${r}> on ${n.constructor.name} CST Visitor.`,type:kt.MISSING_METHOD,methodName:r}));return be(s)}class Vr{initTreeBuilder(e){if(this.CST_STACK=[],this.outputCst=e.outputCst,this.nodeLocationTracking=g(e,"nodeLocationTracking")?e.nodeLocationTracking:ne.nodeLocationTracking,!this.outputCst)this.cstInvocationStateUpdate=C,this.cstFinallyStateUpdate=C,this.cstPostTerminal=C,this.cstPostNonTerminal=C,this.cstPostRule=C;else if(/full/i.test(this.nodeLocationTracking))this.recoveryEnabled?(this.setNodeLocationFromToken=cn,this.setNodeLocationFromNode=cn,this.cstPostRule=C,this.setInitialNodeLocation=this.setInitialNodeLocationFullRecovery):(this.setNodeLocationFromToken=C,this.setNodeLocationFromNode=C,this.cstPostRule=this.cstPostRuleFull,this.setInitialNodeLocation=this.setInitialNodeLocationFullRegular);else if(/onlyOffset/i.test(this.nodeLocationTracking))this.recoveryEnabled?(this.setNodeLocationFromToken=an,this.setNodeLocationFromNode=an,this.cstPostRule=C,this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRecovery):(this.setNodeLocationFromToken=C,this.setNodeLocationFromNode=C,this.cstPostRule=this.cstPostRuleOnlyOffset,this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRegular);else if(/none/i.test(this.nodeLocationTracking))this.setNodeLocationFromToken=C,this.setNodeLocationFromNode=C,this.cstPostRule=C,this.setInitialNodeLocation=C;else throw Error(`Invalid <nodeLocationTracking> config option: "${e.nodeLocationTracking}"`)}setInitialNodeLocationOnlyOffsetRecovery(e){e.location={startOffset:NaN,endOffset:NaN}}setInitialNodeLocationOnlyOffsetRegular(e){e.location={startOffset:this.LA(1).startOffset,endOffset:NaN}}setInitialNodeLocationFullRecovery(e){e.location={startOffset:NaN,startLine:NaN,startColumn:NaN,endOffset:NaN,endLine:NaN,endColumn:NaN}}setInitialNodeLocationFullRegular(e){const t=this.LA(1);e.location={startOffset:t.startOffset,startLine:t.startLine,startColumn:t.startColumn,endOffset:NaN,endLine:NaN,endColumn:NaN}}cstInvocationStateUpdate(e){const t={name:e,children:Object.create(null)};this.setInitialNodeLocation(t),this.CST_STACK.push(t)}cstFinallyStateUpdate(){this.CST_STACK.pop()}cstPostRuleFull(e){const t=this.LA(0),s=e.location;s.startOffset<=t.startOffset?(s.endOffset=t.endOffset,s.endLine=t.endLine,s.endColumn=t.endColumn):(s.startOffset=NaN,s.startLine=NaN,s.startColumn=NaN)}cstPostRuleOnlyOffset(e){const t=this.LA(0),s=e.location;s.startOffset<=t.startOffset?s.endOffset=t.endOffset:s.startOffset=NaN}cstPostTerminal(e,t){const s=this.CST_STACK[this.CST_STACK.length-1];Ur(s,t,e),this.setNodeLocationFromToken(s.location,t)}cstPostNonTerminal(e,t){const s=this.CST_STACK[this.CST_STACK.length-1];Dr(s,t,e),this.setNodeLocationFromNode(s.location,e.location)}getBaseCstVisitorConstructor(){if(te(this.baseCstVisitorConstructor)){const e=$r(this.className,Fe(this.gastProductionsCache));return this.baseCstVisitorConstructor=e,e}return this.baseCstVisitorConstructor}getBaseCstVisitorConstructorWithDefaults(){if(te(this.baseCstVisitorWithDefaultsConstructor)){const e=Br(this.className,Fe(this.gastProductionsCache),this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=e,e}return this.baseCstVisitorWithDefaultsConstructor}getLastExplicitRuleShortName(){const e=this.RULE_STACK;return e[e.length-1]}getPreviousExplicitRuleShortName(){const e=this.RULE_STACK;return e[e.length-2]}getLastExplicitRuleOccurrenceIndex(){const e=this.RULE_OCCURRENCE_STACK;return e[e.length-1]}}class zr{initLexerAdapter(){this.tokVector=[],this.tokVectorLength=0,this.currIdx=-1}set input(e){if(this.selfAnalysisDone!==!0)throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");this.reset(),this.tokVector=e,this.tokVectorLength=e.length}get input(){return this.tokVector}SKIP_TOKEN(){return this.currIdx<=this.tokVector.length-2?(this.consumeToken(),this.LA(1)):et}LA(e){const t=this.currIdx+e;return t<0||this.tokVectorLength<=t?et:this.tokVector[t]}consumeToken(){this.currIdx++}exportLexerState(){return this.currIdx}importLexerState(e){this.currIdx=e}resetLexerState(){this.currIdx=-1}moveToTerminatedState(){this.currIdx=this.tokVector.length-1}getLexerPosition(){return this.exportLexerState()}}class Yr{ACTION(e){return e.call(this)}consume(e,t,s){return this.consumeInternal(t,e,s)}subrule(e,t,s){return this.subruleInternal(t,e,s)}option(e,t){return this.optionInternal(t,e)}or(e,t){return this.orInternal(t,e)}many(e,t){return this.manyInternal(e,t)}atLeastOne(e,t){return this.atLeastOneInternal(e,t)}CONSUME(e,t){return this.consumeInternal(e,0,t)}CONSUME1(e,t){return this.consumeInternal(e,1,t)}CONSUME2(e,t){return this.consumeInternal(e,2,t)}CONSUME3(e,t){return this.consumeInternal(e,3,t)}CONSUME4(e,t){return this.consumeInternal(e,4,t)}CONSUME5(e,t){return this.consumeInternal(e,5,t)}CONSUME6(e,t){return this.consumeInternal(e,6,t)}CONSUME7(e,t){return this.consumeInternal(e,7,t)}CONSUME8(e,t){return this.consumeInternal(e,8,t)}CONSUME9(e,t){return this.consumeInternal(e,9,t)}SUBRULE(e,t){return this.subruleInternal(e,0,t)}SUBRULE1(e,t){return this.subruleInternal(e,1,t)}SUBRULE2(e,t){return this.subruleInternal(e,2,t)}SUBRULE3(e,t){return this.subruleInternal(e,3,t)}SUBRULE4(e,t){return this.subruleInternal(e,4,t)}SUBRULE5(e,t){return this.subruleInternal(e,5,t)}SUBRULE6(e,t){return this.subruleInternal(e,6,t)}SUBRULE7(e,t){return this.subruleInternal(e,7,t)}SUBRULE8(e,t){return this.subruleInternal(e,8,t)}SUBRULE9(e,t){return this.subruleInternal(e,9,t)}OPTION(e){return this.optionInternal(e,0)}OPTION1(e){return this.optionInternal(e,1)}OPTION2(e){return this.optionInternal(e,2)}OPTION3(e){return this.optionInternal(e,3)}OPTION4(e){return this.optionInternal(e,4)}OPTION5(e){return this.optionInternal(e,5)}OPTION6(e){return this.optionInternal(e,6)}OPTION7(e){return this.optionInternal(e,7)}OPTION8(e){return this.optionInternal(e,8)}OPTION9(e){return this.optionInternal(e,9)}OR(e){return this.orInternal(e,0)}OR1(e){return this.orInternal(e,1)}OR2(e){return this.orInternal(e,2)}OR3(e){return this.orInternal(e,3)}OR4(e){return this.orInternal(e,4)}OR5(e){return this.orInternal(e,5)}OR6(e){return this.orInternal(e,6)}OR7(e){return this.orInternal(e,7)}OR8(e){return this.orInternal(e,8)}OR9(e){return this.orInternal(e,9)}MANY(e){this.manyInternal(0,e)}MANY1(e){this.manyInternal(1,e)}MANY2(e){this.manyInternal(2,e)}MANY3(e){this.manyInternal(3,e)}MANY4(e){this.manyInternal(4,e)}MANY5(e){this.manyInternal(5,e)}MANY6(e){this.manyInternal(6,e)}MANY7(e){this.manyInternal(7,e)}MANY8(e){this.manyInternal(8,e)}MANY9(e){this.manyInternal(9,e)}MANY_SEP(e){this.manySepFirstInternal(0,e)}MANY_SEP1(e){this.manySepFirstInternal(1,e)}MANY_SEP2(e){this.manySepFirstInternal(2,e)}MANY_SEP3(e){this.manySepFirstInternal(3,e)}MANY_SEP4(e){this.manySepFirstInternal(4,e)}MANY_SEP5(e){this.manySepFirstInternal(5,e)}MANY_SEP6(e){this.manySepFirstInternal(6,e)}MANY_SEP7(e){this.manySepFirstInternal(7,e)}MANY_SEP8(e){this.manySepFirstInternal(8,e)}MANY_SEP9(e){this.manySepFirstInternal(9,e)}AT_LEAST_ONE(e){this.atLeastOneInternal(0,e)}AT_LEAST_ONE1(e){return this.atLeastOneInternal(1,e)}AT_LEAST_ONE2(e){this.atLeastOneInternal(2,e)}AT_LEAST_ONE3(e){this.atLeastOneInternal(3,e)}AT_LEAST_ONE4(e){this.atLeastOneInternal(4,e)}AT_LEAST_ONE5(e){this.atLeastOneInternal(5,e)}AT_LEAST_ONE6(e){this.atLeastOneInternal(6,e)}AT_LEAST_ONE7(e){this.atLeastOneInternal(7,e)}AT_LEAST_ONE8(e){this.atLeastOneInternal(8,e)}AT_LEAST_ONE9(e){this.atLeastOneInternal(9,e)}AT_LEAST_ONE_SEP(e){this.atLeastOneSepFirstInternal(0,e)}AT_LEAST_ONE_SEP1(e){this.atLeastOneSepFirstInternal(1,e)}AT_LEAST_ONE_SEP2(e){this.atLeastOneSepFirstInternal(2,e)}AT_LEAST_ONE_SEP3(e){this.atLeastOneSepFirstInternal(3,e)}AT_LEAST_ONE_SEP4(e){this.atLeastOneSepFirstInternal(4,e)}AT_LEAST_ONE_SEP5(e){this.atLeastOneSepFirstInternal(5,e)}AT_LEAST_ONE_SEP6(e){this.atLeastOneSepFirstInternal(6,e)}AT_LEAST_ONE_SEP7(e){this.atLeastOneSepFirstInternal(7,e)}AT_LEAST_ONE_SEP8(e){this.atLeastOneSepFirstInternal(8,e)}AT_LEAST_ONE_SEP9(e){this.atLeastOneSepFirstInternal(9,e)}RULE(e,t,s=tt){if(b(this.definedRulesNames,e)){const o={message:fe.buildDuplicateRuleNameError({topLevelRule:e,grammarName:this.className}),type:F.DUPLICATE_RULE_NAME,ruleName:e};this.definitionErrors.push(o)}this.definedRulesNames.push(e);const r=this.defineRule(e,t,s);return this[e]=r,r}OVERRIDE_RULE(e,t,s=tt){const r=Tr(e,this.definedRulesNames,this.className);this.definitionErrors=this.definitionErrors.concat(r);const i=this.defineRule(e,t,s);return this[e]=i,i}BACKTRACK(e,t){return function(){this.isBackTrackingStack.push(1);const s=this.saveRecogState();try{return e.apply(this,t),!0}catch(r){if(Qe(r))return!1;throw r}finally{this.reloadRecogState(s),this.isBackTrackingStack.pop()}}}getGAstProductions(){return this.gastProductionsCache}getSerializedGastProductions(){return Jn(x(this.gastProductionsCache))}}class Xr{initRecognizerEngine(e,t){if(this.className=this.constructor.name,this.shortRuleNameToFull={},this.fullRuleNameToShort={},this.ruleShortNameIdx=256,this.tokenMatcher=Je,this.subruleIdx=0,this.definedRulesNames=[],this.tokensMap={},this.isBackTrackingStack=[],this.RULE_STACK=[],this.RULE_OCCURRENCE_STACK=[],this.gastProductionsCache={},g(t,"serializedGrammar"))throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);if(K(e)){if(O(e))throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);if(typeof e[0].startOffset=="number")throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`)}if(K(e))this.tokensMap=D(e,(i,o)=>(i[o.name]=o,i),{});else if(g(e,"modes")&&q(z(x(e.modes)),Ws)){const i=z(x(e.modes)),o=xt(i);this.tokensMap=D(o,(a,c)=>(a[c.name]=c,a),{})}else if(es(e))this.tokensMap=M(e);else throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");this.tokensMap.EOF=Te;const s=g(e,"modes")?z(x(e.modes)):x(e),r=q(s,i=>O(i.categoryMatches));this.tokenMatcher=r?Je:De,Ge(x(this.tokensMap))}defineRule(e,t,s){if(this.selfAnalysisDone)throw Error(`Grammar rule <${e}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);const r=g(s,"resyncEnabled")?s.resyncEnabled:tt.resyncEnabled,i=g(s,"recoveryValueFunc")?s.recoveryValueFunc:tt.recoveryValueFunc,o=this.ruleShortNameIdx<<Mr+he;this.ruleShortNameIdx++,this.shortRuleNameToFull[o]=e,this.fullRuleNameToShort[e]=o;let a;return this.outputCst===!0?a=function(...h){try{this.ruleInvocationStateUpdate(o,e,this.subruleIdx),t.apply(this,h);const u=this.CST_STACK[this.CST_STACK.length-1];return this.cstPostRule(u),u}catch(u){return this.invokeRuleCatch(u,r,i)}finally{this.ruleFinallyStateUpdate()}}:a=function(...h){try{return this.ruleInvocationStateUpdate(o,e,this.subruleIdx),t.apply(this,h)}catch(u){return this.invokeRuleCatch(u,r,i)}finally{this.ruleFinallyStateUpdate()}},Object.assign(a,{ruleName:e,originalGrammarAction:t})}invokeRuleCatch(e,t,s){const r=this.RULE_STACK.length===1,i=t&&!this.isBackTracking()&&this.recoveryEnabled;if(Qe(e)){const o=e;if(i){const a=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(a))if(o.resyncedTokens=this.reSyncTo(a),this.outputCst){const c=this.CST_STACK[this.CST_STACK.length-1];return c.recoveredNode=!0,c}else return s(e);else{if(this.outputCst){const c=this.CST_STACK[this.CST_STACK.length-1];c.recoveredNode=!0,o.partialCstResult=c}throw o}}else{if(r)return this.moveToTerminatedState(),s(e);throw o}}else throw e}optionInternal(e,t){const s=this.getKeyForAutomaticLookahead(Bn,t);return this.optionInternalLogic(e,t,s)}optionInternalLogic(e,t,s){let r=this.getLaFuncFromCache(s),i;if(typeof e!="function"){i=e.DEF;const o=e.GATE;if(o!==void 0){const a=r;r=()=>o.call(this)&&a.call(this)}}else i=e;if(r.call(this)===!0)return i.call(this)}atLeastOneInternal(e,t){const s=this.getKeyForAutomaticLookahead(Ot,e);return this.atLeastOneInternalLogic(e,t,s)}atLeastOneInternalLogic(e,t,s){let r=this.getLaFuncFromCache(s),i;if(typeof t!="function"){i=t.DEF;const o=t.GATE;if(o!==void 0){const a=r;r=()=>o.call(this)&&a.call(this)}}else i=t;if(r.call(this)===!0){let o=this.doSingleRepetition(i);for(;r.call(this)===!0&&o===!0;)o=this.doSingleRepetition(i)}else throw this.raiseEarlyExitException(e,_.REPETITION_MANDATORY,t.ERR_MSG);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[e,t],r,Ot,e,er)}atLeastOneSepFirstInternal(e,t){const s=this.getKeyForAutomaticLookahead(je,e);this.atLeastOneSepFirstInternalLogic(e,t,s)}atLeastOneSepFirstInternalLogic(e,t,s){const r=t.DEF,i=t.SEP;if(this.getLaFuncFromCache(s).call(this)===!0){r.call(this);const a=()=>this.tokenMatcher(this.LA(1),i);for(;this.tokenMatcher(this.LA(1),i)===!0;)this.CONSUME(i),r.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,i,a,r,rn],a,je,e,rn)}else throw this.raiseEarlyExitException(e,_.REPETITION_MANDATORY_WITH_SEPARATOR,t.ERR_MSG)}manyInternal(e,t){const s=this.getKeyForAutomaticLookahead(St,e);return this.manyInternalLogic(e,t,s)}manyInternalLogic(e,t,s){let r=this.getLaFuncFromCache(s),i;if(typeof t!="function"){i=t.DEF;const a=t.GATE;if(a!==void 0){const c=r;r=()=>a.call(this)&&c.call(this)}}else i=t;let o=!0;for(;r.call(this)===!0&&o===!0;)o=this.doSingleRepetition(i);this.attemptInRepetitionRecovery(this.manyInternal,[e,t],r,St,e,Zs,o)}manySepFirstInternal(e,t){const s=this.getKeyForAutomaticLookahead(_t,e);this.manySepFirstInternalLogic(e,t,s)}manySepFirstInternalLogic(e,t,s){const r=t.DEF,i=t.SEP;if(this.getLaFuncFromCache(s).call(this)===!0){r.call(this);const a=()=>this.tokenMatcher(this.LA(1),i);for(;this.tokenMatcher(this.LA(1),i)===!0;)this.CONSUME(i),r.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,i,a,r,sn],a,_t,e,sn)}}repetitionSepSecondInternal(e,t,s,r,i){for(;s();)this.CONSUME(t),r.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,t,s,r,i],s,je,e,i)}doSingleRepetition(e){const t=this.getLexerPosition();return e.call(this),this.getLexerPosition()>t}orInternal(e,t){const s=this.getKeyForAutomaticLookahead($n,t),r=K(e)?e:e.DEF,o=this.getLaFuncFromCache(s).call(this,r);if(o!==void 0)return r[o].ALT.call(this);this.raiseNoAltException(t,e.ERR_MSG)}ruleFinallyStateUpdate(){if(this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstFinallyStateUpdate(),this.RULE_STACK.length===0&&this.isAtEndOfInput()===!1){const e=this.LA(1),t=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:e,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new Lr(t,e))}}subruleInternal(e,t,s){let r;try{const i=s!==void 0?s.ARGS:void 0;return this.subruleIdx=t,r=e.apply(this,i),this.cstPostNonTerminal(r,s!==void 0&&s.LABEL!==void 0?s.LABEL:e.ruleName),r}catch(i){throw this.subruleInternalError(i,s,e.ruleName)}}subruleInternalError(e,t,s){throw Qe(e)&&e.partialCstResult!==void 0&&(this.cstPostNonTerminal(e.partialCstResult,t!==void 0&&t.LABEL!==void 0?t.LABEL:s),delete e.partialCstResult),e}consumeInternal(e,t,s){let r;try{const i=this.LA(1);this.tokenMatcher(i,e)===!0?(this.consumeToken(),r=i):this.consumeInternalError(e,i,s)}catch(i){r=this.consumeInternalRecovery(e,t,i)}return this.cstPostTerminal(s!==void 0&&s.LABEL!==void 0?s.LABEL:e.name,r),r}consumeInternalError(e,t,s){let r;const i=this.LA(0);throw s!==void 0&&s.ERR_MSG?r=s.ERR_MSG:r=this.errorMessageProvider.buildMismatchTokenMessage({expected:e,actual:t,previous:i,ruleName:this.getCurrRuleFullName()}),this.SAVE_ERROR(new Gn(r,t,i))}consumeInternalRecovery(e,t,s){if(this.recoveryEnabled&&s.name==="MismatchedTokenException"&&!this.isBackTracking()){const r=this.getFollowsForInRuleRecovery(e,t);try{return this.tryInRuleRecovery(e,r)}catch(i){throw i.name===Kn?s:i}}else throw s}saveRecogState(){const e=this.errors,t=M(this.RULE_STACK);return{errors:e,lexerState:this.exportLexerState(),RULE_STACK:t,CST_STACK:this.CST_STACK}}reloadRecogState(e){this.errors=e.errors,this.importLexerState(e.lexerState),this.RULE_STACK=e.RULE_STACK}ruleInvocationStateUpdate(e,t,s){this.RULE_OCCURRENCE_STACK.push(s),this.RULE_STACK.push(e),this.cstInvocationStateUpdate(t)}isBackTracking(){return this.isBackTrackingStack.length!==0}getCurrRuleFullName(){const e=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull[e]}shortRuleNameToFullName(e){return this.shortRuleNameToFull[e]}isAtEndOfInput(){return this.tokenMatcher(this.LA(1),Te)}reset(){this.resetLexerState(),this.subruleIdx=0,this.isBackTrackingStack=[],this.errors=[],this.RULE_STACK=[],this.CST_STACK=[],this.RULE_OCCURRENCE_STACK=[]}}class jr{initErrorHandler(e){this._errors=[],this.errorMessageProvider=g(e,"errorMessageProvider")?e.errorMessageProvider:ne.errorMessageProvider}SAVE_ERROR(e){if(Qe(e))return e.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:M(this.RULE_OCCURRENCE_STACK)},this._errors.push(e),e;throw Error("Trying to save an Error which is not a RecognitionException")}get errors(){return M(this._errors)}set errors(e){this._errors=e}raiseEarlyExitException(e,t,s){const r=this.getCurrRuleFullName(),i=this.getGAstProductions()[r],a=ct(e,i,t,this.maxLookahead)[0],c=[];for(let h=1;h<=this.maxLookahead;h++)c.push(this.LA(h));const l=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:a,actual:c,previous:this.LA(0),customUserDescription:s,ruleName:r});throw this.SAVE_ERROR(new Cr(l,this.LA(1),this.LA(0)))}raiseNoAltException(e,t){const s=this.getCurrRuleFullName(),r=this.getGAstProductions()[s],i=at(e,r,this.maxLookahead),o=[];for(let l=1;l<=this.maxLookahead;l++)o.push(this.LA(l));const a=this.LA(0),c=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:i,actual:o,previous:a,customUserDescription:t,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new kr(c,this.LA(1),a))}}class qr{initContentAssist(){}computeContentAssist(e,t){const s=this.gastProductionsCache[e];if(te(s))throw Error(`Rule ->${e}<- does not exist in this grammar.`);return Cn([s],t,this.tokenMatcher,this.maxLookahead)}getNextPossibleTokenTypes(e){const t=X(e.ruleStack),r=this.getGAstProductions()[t];return new Qs(r,e).startWalking()}}const ht={description:"This Object indicates the Parser is during Recording Phase"};Object.freeze(ht);const ln=!0,hn=Math.pow(2,he)-1,Hn=kn({name:"RECORDING_PHASE_TOKEN",pattern:B.NA});Ge([Hn]);const Vn=Mt(Hn,`This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,-1,-1,-1,-1,-1,-1);Object.freeze(Vn);const Jr={name:`This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,children:{}};class Qr{initGastRecorder(e){this.recordingProdStack=[],this.RECORDING_PHASE=!1}enableRecording(){this.RECORDING_PHASE=!0,this.TRACE_INIT("Enable Recording",()=>{for(let e=0;e<10;e++){const t=e>0?e:"";this[`CONSUME${t}`]=function(s,r){return this.consumeInternalRecord(s,e,r)},this[`SUBRULE${t}`]=function(s,r){return this.subruleInternalRecord(s,e,r)},this[`OPTION${t}`]=function(s){return this.optionInternalRecord(s,e)},this[`OR${t}`]=function(s){return this.orInternalRecord(s,e)},this[`MANY${t}`]=function(s){this.manyInternalRecord(e,s)},this[`MANY_SEP${t}`]=function(s){this.manySepFirstInternalRecord(e,s)},this[`AT_LEAST_ONE${t}`]=function(s){this.atLeastOneInternalRecord(e,s)},this[`AT_LEAST_ONE_SEP${t}`]=function(s){this.atLeastOneSepFirstInternalRecord(e,s)}}this.consume=function(e,t,s){return this.consumeInternalRecord(t,e,s)},this.subrule=function(e,t,s){return this.subruleInternalRecord(t,e,s)},this.option=function(e,t){return this.optionInternalRecord(t,e)},this.or=function(e,t){return this.orInternalRecord(t,e)},this.many=function(e,t){this.manyInternalRecord(e,t)},this.atLeastOne=function(e,t){this.atLeastOneInternalRecord(e,t)},this.ACTION=this.ACTION_RECORD,this.BACKTRACK=this.BACKTRACK_RECORD,this.LA=this.LA_RECORD})}disableRecording(){this.RECORDING_PHASE=!1,this.TRACE_INIT("Deleting Recording methods",()=>{const e=this;for(let t=0;t<10;t++){const s=t>0?t:"";delete e[`CONSUME${s}`],delete e[`SUBRULE${s}`],delete e[`OPTION${s}`],delete e[`OR${s}`],delete e[`MANY${s}`],delete e[`MANY_SEP${s}`],delete e[`AT_LEAST_ONE${s}`],delete e[`AT_LEAST_ONE_SEP${s}`]}delete e.consume,delete e.subrule,delete e.option,delete e.or,delete e.many,delete e.atLeastOne,delete e.ACTION,delete e.BACKTRACK,delete e.LA})}ACTION_RECORD(e){}BACKTRACK_RECORD(e,t){return()=>!0}LA_RECORD(e){return et}topLevelRuleRecord(e,t){try{const s=new Ct({definition:[],name:e});return s.name=e,this.recordingProdStack.push(s),t.call(this),this.recordingProdStack.pop(),s}catch(s){if(s.KNOWN_RECORDER_ERROR!==!0)try{s.message=s.message+`
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`}catch{throw s}throw s}}optionInternalRecord(e,t){return xe.call(this,ee,e,t)}atLeastOneInternalRecord(e,t){xe.call(this,Re,t,e)}atLeastOneSepFirstInternalRecord(e,t){xe.call(this,Ae,t,e,ln)}manyInternalRecord(e,t){xe.call(this,w,t,e)}manySepFirstInternalRecord(e,t){xe.call(this,Ne,t,e,ln)}orInternalRecord(e,t){return Zr.call(this,e,t)}subruleInternalRecord(e,t,s){if(Ze(t),!e||g(e,"ruleName")===!1){const a=new Error(`<SUBRULE${un(t)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);throw a.KNOWN_RECORDER_ERROR=!0,a}const r=ge(this.recordingProdStack),i=e.ruleName,o=new le({idx:t,nonTerminalName:i,label:s==null?void 0:s.LABEL,referencedRule:void 0});return r.definition.push(o),this.outputCst?Jr:ht}consumeInternalRecord(e,t,s){if(Ze(t),!On(e)){const o=new Error(`<CONSUME${un(t)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);throw o.KNOWN_RECORDER_ERROR=!0,o}const r=ge(this.recordingProdStack),i=new y({idx:t,terminalType:e,label:s==null?void 0:s.LABEL});return r.definition.push(i),Vn}}function xe(n,e,t,s=!1){Ze(t);const r=ge(this.recordingProdStack),i=Ee(e)?e:e.DEF,o=new n({definition:[],idx:t});return s&&(o.separator=e.SEP),g(e,"MAX_LOOKAHEAD")&&(o.maxLookahead=e.MAX_LOOKAHEAD),this.recordingProdStack.push(o),i.call(this),r.definition.push(o),this.recordingProdStack.pop(),ht}function Zr(n,e){Ze(e);const t=ge(this.recordingProdStack),s=K(n)===!1,r=s===!1?n:n.DEF,i=new Se({definition:[],idx:e,ignoreAmbiguities:s&&n.IGNORE_AMBIGUITIES===!0});g(n,"MAX_LOOKAHEAD")&&(i.maxLookahead=n.MAX_LOOKAHEAD);const o=ts(r,a=>Ee(a.GATE));return i.hasPredicates=o,t.definition.push(i),R(r,a=>{const c=new Y({definition:[]});i.definition.push(c),g(a,"IGNORE_AMBIGUITIES")?c.ignoreAmbiguities=a.IGNORE_AMBIGUITIES:g(a,"GATE")&&(c.ignoreAmbiguities=!0),this.recordingProdStack.push(c),a.ALT.call(this),this.recordingProdStack.pop()}),ht}function un(n){return n===0?"":`${n}`}function Ze(n){if(n<0||n>hn){const e=new Error(`Invalid DSL Method idx value: <${n}>
	Idx value must be a none negative value smaller than ${hn+1}`);throw e.KNOWN_RECORDER_ERROR=!0,e}}class ei{initPerformanceTracer(e){if(g(e,"traceInitPerf")){const t=e.traceInitPerf,s=typeof t=="number";this.traceInitMaxIdent=s?t:1/0,this.traceInitPerf=s?t>0:t}else this.traceInitMaxIdent=0,this.traceInitPerf=ne.traceInitPerf;this.traceInitIndent=-1}TRACE_INIT(e,t){if(this.traceInitPerf===!0){this.traceInitIndent++;const s=new Array(this.traceInitIndent+1).join("	");this.traceInitIndent<this.traceInitMaxIdent&&console.log(`${s}--> <${e}>`);const{time:r,value:i}=mn(t),o=r>10?console.warn:console.log;return this.traceInitIndent<this.traceInitMaxIdent&&o(`${s}<-- <${e}> time: ${r}ms`),this.traceInitIndent--,i}else return t()}}function ti(n,e){e.forEach(t=>{const s=t.prototype;Object.getOwnPropertyNames(s).forEach(r=>{if(r==="constructor")return;const i=Object.getOwnPropertyDescriptor(s,r);i&&(i.get||i.set)?Object.defineProperty(n.prototype,r,i):n.prototype[r]=t.prototype[r]})})}const et=Mt(Te,"",NaN,NaN,NaN,NaN,NaN,NaN);Object.freeze(et);const ne=Object.freeze({recoveryEnabled:!1,maxLookahead:3,dynamicTokensEnabled:!1,outputCst:!0,errorMessageProvider:Ln,nodeLocationTracking:"none",traceInitPerf:!1,skipValidations:!1}),tt=Object.freeze({recoveryValueFunc:()=>{},resyncEnabled:!0});var F;(function(n){n[n.INVALID_RULE_NAME=0]="INVALID_RULE_NAME",n[n.DUPLICATE_RULE_NAME=1]="DUPLICATE_RULE_NAME",n[n.INVALID_RULE_OVERRIDE=2]="INVALID_RULE_OVERRIDE",n[n.DUPLICATE_PRODUCTIONS=3]="DUPLICATE_PRODUCTIONS",n[n.UNRESOLVED_SUBRULE_REF=4]="UNRESOLVED_SUBRULE_REF",n[n.LEFT_RECURSION=5]="LEFT_RECURSION",n[n.NONE_LAST_EMPTY_ALT=6]="NONE_LAST_EMPTY_ALT",n[n.AMBIGUOUS_ALTS=7]="AMBIGUOUS_ALTS",n[n.CONFLICT_TOKENS_RULES_NAMESPACE=8]="CONFLICT_TOKENS_RULES_NAMESPACE",n[n.INVALID_TOKEN_NAME=9]="INVALID_TOKEN_NAME",n[n.NO_NON_EMPTY_LOOKAHEAD=10]="NO_NON_EMPTY_LOOKAHEAD",n[n.AMBIGUOUS_PREFIX_ALTS=11]="AMBIGUOUS_PREFIX_ALTS",n[n.TOO_MANY_ALTS=12]="TOO_MANY_ALTS",n[n.CUSTOM_LOOKAHEAD_VALIDATION=13]="CUSTOM_LOOKAHEAD_VALIDATION"})(F||(F={}));function ii(n=void 0){return function(){return n}}class Ke{static performSelfAnalysis(e){throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.")}performSelfAnalysis(){this.TRACE_INIT("performSelfAnalysis",()=>{let e;this.selfAnalysisDone=!0;const t=this.className;this.TRACE_INIT("toFastProps",()=>{Tn(this)}),this.TRACE_INIT("Grammar Recording",()=>{try{this.enableRecording(),R(this.definedRulesNames,r=>{const o=this[r].originalGrammarAction;let a;this.TRACE_INIT(`${r} Rule`,()=>{a=this.topLevelRuleRecord(r,o)}),this.gastProductionsCache[r]=a})}finally{this.disableRecording()}});let s=[];if(this.TRACE_INIT("Grammar Resolving",()=>{s=Or({rules:x(this.gastProductionsCache)}),this.definitionErrors=this.definitionErrors.concat(s)}),this.TRACE_INIT("Grammar Validations",()=>{if(O(s)&&this.skipValidations===!1){const r=_r({rules:x(this.gastProductionsCache),tokenTypes:x(this.tokensMap),errMsgProvider:fe,grammarName:t}),i=lr({lookaheadStrategy:this.lookaheadStrategy,rules:x(this.gastProductionsCache),tokenTypes:x(this.tokensMap),grammarName:t});this.definitionErrors=this.definitionErrors.concat(r,i)}}),O(this.definitionErrors)&&(this.recoveryEnabled&&this.TRACE_INIT("computeAllProdsFollows",()=>{const r=os(x(this.gastProductionsCache));this.resyncFollows=r}),this.TRACE_INIT("ComputeLookaheadFunctions",()=>{var r,i;(i=(r=this.lookaheadStrategy).initialize)===null||i===void 0||i.call(r,{rules:x(this.gastProductionsCache)}),this.preComputeLookaheadFunctions(x(this.gastProductionsCache))})),!Ke.DEFER_DEFINITION_ERRORS_HANDLING&&!O(this.definitionErrors))throw e=E(this.definitionErrors,r=>r.message),new Error(`Parser Definition Errors detected:
 ${e.join(`
-------------------------------
`)}`)})}constructor(e,t){this.definitionErrors=[],this.selfAnalysisDone=!1;const s=this;if(s.initErrorHandler(t),s.initLexerAdapter(),s.initLooksAhead(t),s.initRecognizerEngine(e,t),s.initRecoverable(t),s.initTreeBuilder(t),s.initContentAssist(),s.initGastRecorder(t),s.initPerformanceTracer(t),g(t,"ignoredIssues"))throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);this.skipValidations=g(t,"skipValidations")?t.skipValidations:ne.skipValidations}}Ke.DEFER_DEFINITION_ERRORS_HANDLING=!1;ti(Ke,[Pr,Fr,Vr,zr,Xr,Yr,jr,qr,Qr,ei]);class oi extends Ke{constructor(e,t=ne){const s=M(t);s.outputCst=!1,super(e,s)}}export{oi as E,vr as L,Ys as a,ii as b,Te as c,Ln as d,B as e,ri as g,ve as t};
